```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) 
```

## Proteome-wide Screen for RNA-dependent Proteins:

## *non-synchronized A549 cells*

Zum PDF exportieren

```{r}
tinytex::install_tinytex()
```

Loading the data:

```{r}
MS_Table <- read.delim('https://www.dropbox.com/s/vm3lxljjm9chau8/RDeeP_A549_NS.csv?dl=1', header=TRUE, row.names=1, sep = ";")
```

## 0. Data description

```{r}
dim(MS_Table)
head(rownames(MS_Table))
head(colnames(MS_Table))
```

## 1. Preparing data for analysis

### 1.1 Check for missing values

```{r}
sum(apply(MS_Table, 1, anyNA)) == 0
sum(is.na(MS_Table)) == 0
```

### 1.2 Check data format

```{r}
sum(apply(MS_Table, 1, is.numeric)) == nrow(MS_Table)
```

### 1.3 Deleting rows with only zeros

```{r}
min(MS_Table)
sum(apply(MS_Table,1,sum)==0)
```

-\> da die Summe der Zeileneinträge keines Proteins 0 entspricht, wurde ein Dataframe aus False erstellt. Einträge ausschließlich False, werden durch die sum Funktion als 0 aufaddiert.

### 1.4 Rearranging of Data

#### 1.4.1 Reordering columns

```{r}
MS_Table_reordered <- MS_Table[, c(
  paste0("Fraction", 1:25, "_Ctrl_Rep1"),
  paste0("Fraction", 1:25, "_Ctrl_Rep2"),
  paste0("Fraction", 1:25, "_Ctrl_Rep3"),
  paste0("Fraction", 1:25, "_RNase_Rep1"),
  paste0("Fraction", 1:25, "_RNase_Rep2"),
  paste0("Fraction", 1:25, "_RNase_Rep3")
)]
# View(MS_Table_reordered)
sum(apply(MS_Table_reordered, 2, is.numeric)) == ncol(MS_Table)
```

#### 1.4.2 Separate Ctrl and RNase

```{r}
MS_Table_Ctrl <-MS_Table_reordered[,1:75]
#View(MS_Table_Ctrl)
MS_Table_RNase <-MS_Table_reordered[,76:150]
#View(MS_Table_RNase)
```

## 2. Scale and Reduce Dataset

### 2.1a Normalization (mean value methode)

For the normalization each replicate has to be separated, therefore we design 6 separate dataframes.

```{r}
MS_Table_Ctrl_rep1 <-MS_Table_reordered[,1:25]
MS_Table_Ctrl_rep2 <-MS_Table_reordered[,26:50]
MS_Table_Ctrl_rep3 <-MS_Table_reordered[,51:75]
MS_Table_RNase_rep1 <-MS_Table_reordered[,76:100]
MS_Table_RNase_rep2 <-MS_Table_reordered[,101:125]
MS_Table_RNase_rep3 <-MS_Table_reordered[,126:150]
```

On them we apply separately the mean value methode.

```{r}
#rowMeans(MS_Table_Ctrl_rep1)
#apply(MS_Table_Ctrl_rep1,1,sd)
MS_Table_Ctrl_rep1_normalized <- apply(t(MS_Table_Ctrl_rep1),1, function(x)(x - mean(x)) / sd(x))
View(MS_Table_Ctrl_rep1_normalized)
# Der oben stehende code führt nicht die mean value methode durch. Daher siehe unten.  
```

Another idea to apply the mean value method on each row of every dataframe. All values below 0 are set back to 0.

```{r}

# MS_Table_Ctrl_rep1
MS_Table_Ctrl_rep1_normalized <- t(apply(MS_Table_Ctrl_rep1, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  return(normalized)
}))

# View(MS_Table_Ctrl_rep1_normalized)

# MS_Table_Ctrl_rep2
MS_Table_Ctrl_rep2_normalized <- t(apply(MS_Table_Ctrl_rep2, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  return(normalized)
}))

# MS_Table_Ctrl_rep3
MS_Table_Ctrl_rep3_normalized <- t(apply(MS_Table_Ctrl_rep3, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  return(normalized)
}))

# MS_Table_RNase_rep1
MS_Table_RNase_rep1_normalized <- t(apply(MS_Table_RNase_rep1, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  return(normalized)
}))

# MS_Table_RNase_rep2
MS_Table_RNase_rep2_normalized <- t(apply(MS_Table_RNase_rep2, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  return(normalized)
}))

# MS_Table_RNase_rep3
MS_Table_RNase_rep3_normalized <- t(apply(MS_Table_RNase_rep3, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  return(normalized)
}))

```

Hier eine Möglichkeit direkt mit der Normalisierung auch noch die Skalierung auf 100 durchzuführen

```{r}
# MS_Table_Ctrl_rep1
MS_Table_Ctrl_rep1_normalized <- t(apply(MS_Table_Ctrl_rep1, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# View(MS_Table_Ctrl_rep1_normalized)

# MS_Table_Ctrl_rep2
MS_Table_Ctrl_rep2_normalized <- t(apply(MS_Table_Ctrl_rep2, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# MS_Table_Ctrl_rep3
MS_Table_Ctrl_rep3_normalized <- t(apply(MS_Table_Ctrl_rep3, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# MS_Table_RNase_rep1
MS_Table_RNase_rep1_normalized <- t(apply(MS_Table_RNase_rep1, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# MS_Table_RNase_rep2
MS_Table_RNase_rep2_normalized <- t(apply(MS_Table_RNase_rep2, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# MS_Table_RNase_rep3
MS_Table_RNase_rep3_normalized <- t(apply(MS_Table_RNase_rep3, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

```

An idea to check the reproducibility -\> das hinzufügen der Funktion as.numeric hat das Problem gelöst

```{r}
num_rows <- nrow(MS_Table_Ctrl_rep1)

# create vector 
correlations <- numeric(num_rows) 


for (i in 1:num_rows) {
  # select row i from MS_Table_Ctrl_rep1 and MS_Table_Ctrl_rep2 
  row_rep1 <- as.numeric(MS_Table_Ctrl_rep1[i, ]) 
  # Der Fehler war, dass die Rows nicht als Vector, sondern als Dataframe eingelesen wurden -> Sobald der Type richtig ist, kann er auch die Correlation ausrechnen. 
  # Als weiterer Hinweis jedoch: Die Operation könnte etwas länger dauern, wenn ihrs für alle dfs macht. 
  row_rep2 <- as.numeric(MS_Table_Ctrl_rep2[i, ])
  
  
  correlation <- cor(row_rep1, row_rep2, method = "pearson")
  
  
  correlations[i] <- correlation
}

# show result 
correlations

#Achtung: funktioniert nicht, aber ich weiß nicht warum Fehlermeldung auftritt

```

### 2.1b Normalization (Min-Max-Scaling)

For the normalization each replicate has to be separated, therefore we design 6 separate dataframes.(This step resembles to 2.1, but this way we can avoid any confusion)

```{r}
ctrl.rep1.MMS <-MS_Table_reordered[,1:25]
ctrl.rep2.MMS <-MS_Table_reordered[,26:50]
ctrl.rep3.MMS <-MS_Table_reordered[,51:75]
rnase.rep1.MMS <-MS_Table_reordered[,76:100]
rnase.rep2.MMS <-MS_Table_reordered[,101:125]
rnase.rep3.MMS <-MS_Table_reordered[,126:150]
```

On them we apply Min-Max-Scaling:

```{r}

# ctrl.rep1.MMS
ctrl.rep1.MMS.norm <- t(apply(ctrl.rep1.MMS, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# ctrl.rep2.MMS
ctrl.rep2.MMS.norm <- t(apply(ctrl.rep2.MMS, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# ctrl.rep3.MMS
ctrl.rep3.MMS.norm <- t(apply(ctrl.rep3.MMS, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# rnase.rep1.MMS
rnase.rep1.MMS.norm <- t(apply(rnase.rep1.MMS, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# rnase.rep2.MMS
rnase.rep2.MMS.norm <- t(apply(rnase.rep2.MMS, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# rnase.rep3.MMS
rnase.rep3.MMS.norm <- t(apply(rnase.rep3.MMS, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))
```

To prove that the algorithm works we use is on a test matrix: (byrow = TRUE, dass die Zahen Zeilenweise die Matrix füllen, nicht spaltenweise)

```{r}
test_matrix <- matrix(c(1,45,3,8,27,4,79,30,0,100,99,50,0,76,1,4,6,3,8,7,3), byrow = TRUE, nrow = 3)

test_normalized <- t(apply(test_matrix, 1, function(x){
  normalized <- (x-min(x))/(max(x)-min(x))
}))

#test_matrix
#test_normalized
```

Now we merge the three replicates:

```{r}
ctrl.MMS.merged <- ((ctrl.rep1.MMS.norm + ctrl.rep2.MMS.norm + ctrl.rep3.MMS.norm)/3)

rnase.MMS.merged <- ((rnase.rep1.MMS.norm + rnase.rep2.MMS.norm + rnase.rep3.MMS.norm)/3)
```

Those have to be scaled again:

```{r}
ctrl.MMS <- t(apply(ctrl.MMS.merged, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

rnase.MMS <- t(apply(rnase.MMS.merged, 1, function(x){
  normalized <- (x-min(x))/(max(x)-min(x))
}))
```

Now we can plot graphs that show the result of the merge and second scaling. This is only an example (control sample of the first protein), the plotting of all proteins will be done later on:

```{r}
#plots of the scaled replicates
plot(rnase.rep1.MMS.norm[1,], xlab="fraction", ylab="protein amount", col="green", pch=20)
plot(rnase.rep2.MMS.norm[1,], xlab="fraction", ylab="protein amount", col="green", pch=20)
plot(rnase.rep3.MMS.norm[1,], xlab="fraction", ylab="protein amount", col="green", pch=20)

#plot of the merged ctrl
plot(rnase.MMS.merged[1,], xlab="fraction", ylab="protein amount", col="red", pch=20)

#plot of the merged and scaled ctrl
plot(rnase.MMS[1,], xlab="fraction", ylab="protein amount", col="blue", pch=20)
```
