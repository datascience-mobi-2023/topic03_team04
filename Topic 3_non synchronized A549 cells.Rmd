```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) 
```

# Proteome-wide Screen for RNA-dependent Proteins: *non-synchronized A549 cells*

Zum PDF exportieren

```{r}
#tinytex::install_tinytex()
```

Loading the data:

```{r}
MS_Table <- read.delim('https://www.dropbox.com/s/vm3lxljjm9chau8/RDeeP_A549_NS.csv?dl=1', header=TRUE, row.names=1, sep = ";")
```

## 0. Data description

```{r}
dim(MS_Table)
head(rownames(MS_Table))
head(colnames(MS_Table))
```

## 1. Preparing data for analysis

### 1.1. Check for missing values

```{r}
sum(apply(MS_Table, 1, anyNA)) == 0
sum(is.na(MS_Table)) == 0
```

### 1.2. Check data format

```{r}
sum(apply(MS_Table, 1, is.numeric)) == nrow(MS_Table)
```

### 1.3. Deleting rows with only zeros

```{r}
min(MS_Table)
sum(apply(MS_Table,1,sum)==0)
```

-\> da die Summe der Zeileneinträge keines Proteins 0 entspricht, wurde ein Dataframe aus False erstellt. Einträge ausschließlich False, werden durch die sum Funktion als 0 aufaddiert.

### 1.4. Rearranging of Data

#### 1.4.1. Reordering columns

```{r}
MS_Table_reordered <- MS_Table[, c(
  paste0("Fraction", 1:25, "_Ctrl_Rep1"),
  paste0("Fraction", 1:25, "_Ctrl_Rep2"),
  paste0("Fraction", 1:25, "_Ctrl_Rep3"),
  paste0("Fraction", 1:25, "_RNase_Rep1"),
  paste0("Fraction", 1:25, "_RNase_Rep2"),
  paste0("Fraction", 1:25, "_RNase_Rep3")
)]
# View(MS_Table_reordered)
sum(apply(MS_Table_reordered, 2, is.numeric)) == ncol(MS_Table)
```

#### 1.4.2. Separate Ctrl and RNase

```{r}
MS_Table_Ctrl <-MS_Table_reordered[,1:75]
#View(MS_Table_Ctrl)
MS_Table_RNase <-MS_Table_reordered[,76:150]
View(MS_Table_RNase)
```

## 2. Reproducibility

Here we test whether the replicates are similar to each other. This would mean, that the experiment is reproducible, thus the data is reliable. Proteins that do not satisfy this condition will be removed from the dataset and will not be analysed.

#### 2.1 Pearson Correlation

To facilitate the calculation of the correlation between each replicate, we design 6 separate data frames, one for each replicate

```{r}
ctrl.rep1.reprod <- MS_Table_reordered[,1:25]
ctrl.rep2.reprod <- MS_Table_reordered[,26:50]
ctrl.rep3.reprod <- MS_Table_reordered[,51:75]
rnase.rep1.reprod <- MS_Table_reordered[,76:100]
rnase.rep2.reprod <- MS_Table_reordered[,101:125]
rnase.rep3.reprod <- MS_Table_reordered[,126:150]
```

Here we calculate the correlation between the replicates and put them together in one data frame (ctrl.cor and rnase.cor) (?)

```{r, echo=FALSE, warning = FALSE}
ctrl.cor <- 
  cbind(ctrl.cor.rep1.rep2 <- 
          sapply(seq.int(dim(ctrl.rep1.reprod)[1]), function(x) cor(as.numeric(ctrl.rep1.reprod[x,]), as.numeric(ctrl.rep2.reprod[x,]))),
        ctrl.cor.rep2.rep3 <- 
          sapply(seq.int(dim(ctrl.rep1.reprod)[1]), function(x) cor(as.numeric(ctrl.rep2.reprod[x,]), as.numeric(ctrl.rep3.reprod[x,]))), 
        ctrl.cor.rep1.rep3 <- 
          sapply(seq.int(dim(ctrl.rep1.reprod)[1]), function(x) cor(as.numeric(ctrl.rep1.reprod[x,]), as.numeric(ctrl.rep3.reprod[x,]))))

rnase.cor <- 
  cbind(rnase.cor.rep1.rep2 <- 
         sapply(seq.int(dim(rnase.rep1.reprod)[1]), function(x) cor(as.numeric(rnase.rep1.reprod[x,]), as.numeric(rnase.rep2.reprod[x,]))),
        rnase.cor.rep2.rep3 <- 
          sapply(seq.int(dim(rnase.rep1.reprod)[1]), function(x) cor(as.numeric(rnase.rep2.reprod[x,]), as.numeric(rnase.rep3.reprod[x,]))), 
        rnase.cor.rep1.rep3 <- 
          sapply(seq.int(dim(rnase.rep1.reprod)[1]), function(x) cor(as.numeric(rnase.rep1.reprod[x,]), as.numeric(rnase.rep3.reprod[x,]))))

ctrl.rnase.cor <- cbind(ctrl.cor,rnase.cor)
```

Now we eliminate proteins which have NA-correlations (this happens when they contain replicates with only 0s). We then create new separate data frames for each replicate.

```{r}
total.na <- which(rowSums(is.na(ctrl.rnase.cor)) > 0)
length(total.na)
MS.Table.naremoved <- MS_Table_reordered[-total.na,]

ctrl.rep1.naremoved <- MS.Table.naremoved[,1:25]
ctrl.rep2.naremoved <- MS.Table.naremoved[,26:50]
ctrl.rep3.naremoved <- MS.Table.naremoved[,51:75]
rnase.rep1.naremoved <- MS.Table.naremoved[,76:100]
rnase.rep2.naremoved <- MS.Table.naremoved[,101:125]
rnase.rep3.naremoved <- MS.Table.naremoved[,126:150]
```

Now we calculate the correlation of the replicates. This time the proteins that containes replicates with only 0 are eliminated, so there should be no NAs anymore.

```{r}
ctrl.cor.naremoved <- 
  cbind(ctrl.cor.rep1.rep2.naremoved <- 
          sapply(seq.int(dim(ctrl.rep1.naremoved)[1]), function(x) cor(as.numeric(ctrl.rep1.naremoved[x,]), as.numeric(ctrl.rep2.naremoved[x,]))),
        ctrl.cor.rep2.rep3.naremoved <- 
          sapply(seq.int(dim(ctrl.rep1.naremoved)[1]), function(x) cor(as.numeric(ctrl.rep2.naremoved[x,]), as.numeric(ctrl.rep3.naremoved[x,]))), 
        ctrl.cor.rep1.rep3.naremoved <- 
          sapply(seq.int(dim(ctrl.rep1.naremoved)[1]), function(x) cor(as.numeric(ctrl.rep1.naremoved[x,]), as.numeric(ctrl.rep3.naremoved[x,]))))

rnase.cor.naremoved <- 
  cbind(rnase.cor.rep1.rep2.naremoved <- 
         sapply(seq.int(dim(rnase.rep1.naremoved)[1]), function(x) cor(as.numeric(rnase.rep1.naremoved[x,]), as.numeric(rnase.rep2.naremoved[x,]))),
        rnase.cor.rep2.rep3.naremoved <- 
          sapply(seq.int(dim(rnase.rep1.naremoved)[1]), function(x) cor(as.numeric(rnase.rep2.naremoved[x,]), as.numeric(rnase.rep3.naremoved[x,]))), 
        rnase.cor.rep1.rep3.naremoved <- 
          sapply(seq.int(dim(rnase.rep1.naremoved)[1]), function(x) cor(as.numeric(rnase.rep1.naremoved[x,]), as.numeric(rnase.rep3.naremoved[x,]))))

#View(ctrl.cor.naremoved)
```

The following plot shows us the general distribution of correlation.

In total we look at 3\*(3680-83) correlations This has to be taken into account, when looking at the graphs. It is import to figure out if the 3 cor are for one protein or for 3 different ones.

```{r}
library(ggplot2)
ctrl.cor.data.frame.naremoved <- data.frame(c(ctrl.cor.naremoved[,1],ctrl.cor.naremoved[,2],ctrl.cor.naremoved[,3]))
colnames(ctrl.cor.data.frame.naremoved) <- "correlation"
ggplot(ctrl.cor.data.frame.naremoved, aes(x=correlation)) + geom_histogram()
```

We do the same for the RNase group:

```{r}
library(ggplot2)
rnase.cor.data.frame.naremoved <- data.frame(c(rnase.cor.naremoved[,1],rnase.cor.naremoved[,2],rnase.cor.naremoved[,3]))
colnames(rnase.cor.data.frame.naremoved) = "correlation"
ggplot(rnase.cor.data.frame.naremoved, aes(x=correlation)) + geom_histogram()
```

Now we select the proteins which have correlations beneath 0.9. Those are not reproducible, thus the data is not safe enough to be used further.

First we determine the proteins that only have correlations under 0.9.

```{r}

non.reproducible.ctrl <- which(rowSums(ctrl.cor.naremoved<0.9)>2)
#length(non.reproducible.ctrl)

non.reproducible.rnase <- which(rowSums(rnase.cor.naremoved<0.9)>2)
#length(non.reproducible.rnase)

non.reproducible <- unique(c(non.reproducible.ctrl, non.reproducible.rnase))
#length(non.reproducible)

length(non.reproducible.rnase)
length(non.reproducible.ctrl)

#View(non.reproducible2)
```

Now we eliminate the proteins that only have correlations under 0.9.

```{r}

ctrl.rep <- MS.Table.naremoved[-non.reproducible,1:75]
rnase.rep <- MS.Table.naremoved[-non.reproducible,76:150]

ctrl.cor.removed <- ctrl.cor.naremoved [-non.reproducible,]
rnase.cor.removed <- rnase.cor.naremoved [-non.reproducible,]


length(non.reproducible)
#View(ctrl.rep)
#View(MS.Table.naremoved[,1:75])
#View(non.reproducible)
```

Other proteins are a bit trickier. Some proteins have two replicates similar to each other (correlation \< 0.9) and a third one that completely differs. These Proteins have one very high and two smaller correlations. The different replicate is often the third one (mabye batch effect). To avoid loosing too many proteins and still to still have safe data, we try to ignore the bad replicates. For this we first set them to NA: After the normalization-set we can ignore them.

```{r}

for (x in 1:dim(ctrl.rep)[1]){
  if (ctrl.cor.removed[x, 1] < 0.9) {
    if (ctrl.cor.removed[x, 3] < 0.9){
      ctrl.rep[x, 1:25] <- NA 
    }
    if (ctrl.cor.removed[x, 2] < 0.9){
      ctrl.rep[x, 26:50] <- NA
    }}
  
  if (ctrl.cor.removed[x, 3] < 0.9) {
    if (ctrl.cor.removed[x, 2] < 0.9){
      ctrl.rep[x, 51:75] <- NA
    }
  }
     }

for (x in 1:dim(rnase.rep)[1]){
  if (rnase.cor.removed[x, 1] < 0.9) {
    if (rnase.cor.removed[x, 3] < 0.9){
      rnase.rep[x, 1:25] <- NA 
    }
    if (rnase.cor.removed[x, 2] < 0.9){
      rnase.rep[x, 26:50] <- NA
    }}
  
  if (rnase.cor.removed[x, 3] < 0.9) {
    if (rnase.cor.removed[x, 2] < 0.9){
      rnase.rep[x, 51:75] <- NA
    }
  }
}

Nr <- c(1:dim(rnase.rep)[1])
rnase.with.proteinnumbers <- cbind(Nr, rnase.rep[,1:25], Nr, rnase.rep[,26:50], Nr, rnase.rep[,51:75])
#View(rnase.with.proteinnumbers)
#View(rnase.cor.removed)

ctrl.with.proteinnumbers <- cbind(Nr, ctrl.rep[,1:25], Nr, ctrl.rep[,26:50], Nr, ctrl.rep[,51:75])
#View(ctrl.with.proteinnumbers)

```

We now have 3074 Proteins left. They are stored in new variables:

We now have clean data, with proteins that have reproducible data we can use for further analysis.

## 3. Scaled and Reduced Dataset

For the normalization each replicate has to be separated, therefore we design 6 separate dataframes.

```{r}
ctrl.rep1 <- ctrl.clean[,1:25]
ctrl.rep2 <- ctrl.clean[,26:50]
ctrl.rep3 <- ctrl.clean[,51:75]
rnase.rep1 <- rnase.clean[,1:25]
rnase.rep2 <- rnase.clean[,26:50]
rnase.rep3 <- rnase.clean[,51:75]
```

### 3.1. Mean Value Method

#### 3.1.1. Normalization

We perform the mean-value-method (mvm) on each replicate, both control and RNase:

```{r}
# Control Replicate 1 MVM
ctrl.rep1.mvm.norm <- t(apply(ctrl.rep1, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# View(ctrl.rep1.mvm.norm)

# Control Replicate 2 MVM
ctrl.rep2.mvm.norm <- t(apply(ctrl.rep2, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# Control Replicate 3 MVM
ctrl.rep3.mvm.norm <- t(apply(ctrl.rep3, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# RNase Replicate 1 MVM
rnase.rep1.mvm.norm <- t(apply(rnase.rep1, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# RNase Replicate 2 MVM
rnase.rep2.mvm.norm <- t(apply(rnase.rep2, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# RNase Replicate 3 MVM
rnase.rep3.mvm.norm <- t(apply(rnase.rep3, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

```

#### 3.1.2. Reduction

To reduce we take the mean value between each replicate. Here we must consider the NA-values of non-reproducible replicates.

```{r}

r1c <- ctrl.rep1.mvm.norm
r2c <- ctrl.rep2.mvm.norm
r3c <- ctrl.rep3.mvm.norm

r1c0 <- ctrl.rep1.mvm.norm
r2c0 <- ctrl.rep2.mvm.norm
r3c0 <- ctrl.rep3.mvm.norm

r1c0[is.na(r1c)] <- 0
r2c0[is.na(r2c)] <- 0
r3c0[is.na(r3c)] <- 0


ctrl.mvm.reduced <-  (r1c0 + r2c0 + r3c0)/(3-((sum(is.na(r1c[x,]) + is.na(r2c[x,]) + is.na(r3c[x,])))/25))

```

```{r}

r1r <- rnase.rep1.mvm.norm
r2r <- rnase.rep2.mvm.norm
r3r <- rnase.rep3.mvm.norm

r1r0 <- rnase.rep1.mvm.norm
r2r0 <- rnase.rep2.mvm.norm
r3r0 <- rnase.rep3.mvm.norm

r1r0[is.na(r1r)] <- 0
r2r0[is.na(r2r)] <- 0
r3r0[is.na(r3r)] <- 0

rnase.mvm.reduced <-  (r1r0 + r2r0 + r3r0)/(3 - ((sum(is.na(r1r[x,]) + is.na(r2r[x,]) + is.na(r3r[x,])))/25))
                        

#View(rnase.mvm.reduced)
```

#### 3.1.3. Scaling

To test whether we have "lost" our scaling during the merge, and find out whether scaling back to 100 is necessary, we scale the control to 100 and compare it with the original control.

```{r}
ctrl.mvm.scaled = 
  sweep(ctrl.mvm.reduced,1,100/rowSums(ctrl.mvm.reduced),'*')

# Check if the two data frames are identical
is_identical <- identical(ctrl.mvm.reduced, ctrl.mvm.scaled)

# Print the result
if (is_identical) {
  print("The data frames are identical.")
 } else {
  print("The data frames are not identical.")
 }
```

-\> scaling back to 100 is necessary

Because scaling back to 100 is necessary, we do it for the RNase too:

```{r}
rnase.mvm.scaled = 
  sweep(rnase.mvm.reduced,1,100/rowSums(rnase.mvm.reduced),'*')

```

Now we have normalized our data using the mean-value-method, and scaled it to 100. The two variables that will be used later on either contain the normalized (mvm) and scaled data of the control: **ctrl.mvm** or the normalized (mvm) and scaled data of the rnase: **rnase.mvm**

```{r}
new.colnames.ctrl <- c("Fraction_1_Ctrl","Fraction_2_Ctrl","Fraction_3_Ctrl","Fraction_4_Ctrl","Fraction_5_Ctrl","Fraction_6_Ctrl","Fraction_7_Ctrl","Fraction_8_Ctrl","Fraction_9_Ctrl","Fraction_10_Ctrl","Fraction_11_Ctrl","Fraction_12_Ctrl","Fraction_13_Ctrl","Fraction_14_Ctrl","Fraction_15_Ctrl","Fraction_16_Ctrl","Fraction_17_Ctrl","Fraction_18_Ctrl","Fraction_19_Ctrl","Fraction_20_Ctrl","Fraction_21_Ctrl","Fraction_22_Ctrl","Fraction_23_Ctrl","Fraction_24_Ctrl","Fraction_25_Ctrl")

new.colnames.rnase <- c("Fraction_1_RNase","Fraction_2_RNase","Fraction_3_RNase","Fraction_4_RNase","Fraction_5_RNase","Fraction_6_RNase","Fraction_7_RNase","Fraction_8_RNase","Fraction_9_RNase","Fraction_10_RNase","Fraction_11_RNase","Fraction_12_RNase","Fraction_13_RNase","Fraction_14_RNase","Fraction_15_RNase","Fraction_16_RNase","Fraction_17_RNase","Fraction_18_RNase","Fraction_19_RNase","Fraction_20_RNase","Fraction_21_RNase","Fraction_22_RNase","Fraction_23_RNase","Fraction_24_RNase","Fraction_25_RNase")

ctrl.mvm <- ctrl.mvm.scaled
colnames(ctrl.mvm) <- new.colnames.ctrl

rnase.mvm <- rnase.mvm.scaled
colnames(rnase.mvm) <- new.colnames.rnase
```

### 3.2. z - Transformation

#### 3.2.1. Normalization

The z-Transformation does not work with df that have NA-values. This means we cannot use the ctrl.clean and rnase.clean df. We have to use the old ctrl.rep or the MS.Table.naremoved[-non.reproducible,1:75] dfs. On these we first perform z-Transformation and then we use the same algorithms as before to reduce the dataset in regards to reproducibility. (boah mein Elglisch)

```{r}
ctrl.rep.zt <- MS.Table.naremoved[-non.reproducible,1:75]
rnase.rep.zt <- MS.Table.naremoved[-non.reproducible,76:150]

ctrl.rep1z <- ctrl.rep.zt[,1:25]
ctrl.rep2z <- ctrl.rep.zt[,26:50]
ctrl.rep3z <- ctrl.rep.zt[,51:75]
ctrl.repz <- cbind(ctrl.rep1z,ctrl.rep2z,ctrl.rep3z)


rnase.rep1z <- rnase.rep.zt[,1:25]
rnase.rep2z <- rnase.rep.zt[,26:50]
rnase.rep3z <- rnase.rep.zt[,51:75]
rnase.repz <- cbind(rnase.rep1z,rnase.rep2z,rnase.rep3z)
```

First the normalization for the Ctrl: 

Since the protein amount in each replicate is different, it is better to calculate the mean for each replicate separately. However the sd-value does not have to be adapted. Because the replicates have the same variance (same procedure for every replicate in the wet lab), we don't have to calculate the standard devidation for the replicates in each fraction extra. We can calculate the sd-value for one row /sd.

*sd-values and mean values of Ctrl:*

```{r}
sd.ctrl <- apply(ctrl.repz, 1, sd)

mean.ctrl.rep1 <- apply(ctrl.rep1z, 1, mean)
mean.ctrl.rep2 <- apply(ctrl.rep2z, 1, mean)
mean.ctrl.rep3 <- apply(ctrl.rep3z, 1, mean)
```

*Normalization of Ctrl:*

```{r}
ctrl.rep1.meanvalue <- sweep(ctrl.rep1z,1,mean.ctrl.rep1,'-')
ctrl.rep1.zt.norm <- sweep(ctrl.rep1.meanvalue,1,sd.ctrl,'/')

ctrl.rep2.meanvalue <- sweep(ctrl.rep2z,1,mean.ctrl.rep2,'-')
ctrl.rep2.zt.norm <- sweep(ctrl.rep2.meanvalue,1,sd.ctrl,'/')

ctrl.rep3.meanvalue <- sweep(ctrl.rep3z,1,mean.ctrl.rep3,'-')
ctrl.rep3.zt.norm <- sweep(ctrl.rep3.meanvalue,1,sd.ctrl,'/')

#calculate again the min value for each protein
min.ctrl.rep1.zt.norm <- apply(ctrl.rep1.zt.norm, 1, min)
min.ctrl.rep2.zt.norm <- apply(ctrl.rep2.zt.norm, 1, min)
min.ctrl.rep3.zt.norm <- apply(ctrl.rep3.zt.norm, 1, min)

#substract the min value from each position to discard the 0
ctrl.rep1.zt.norm.pos <- sweep(ctrl.rep1.zt.norm,1,min.ctrl.rep1.zt.norm,FUN = '-')
ctrl.rep2.zt.norm.pos <- sweep(ctrl.rep2.zt.norm,1,min.ctrl.rep2.zt.norm,FUN = '-')
ctrl.rep3.zt.norm.pos <- sweep(ctrl.rep3.zt.norm,1,min.ctrl.rep3.zt.norm,FUN = '-')
```

*sd-values and mean values of RNase:*

```{r}
sd.rnase = apply(rnase.repz, 1, sd)

mean.rnase.rep1 <- apply(rnase.rep1z, 1, mean)
mean.rnase.rep2 <- apply(rnase.rep2z, 1, mean)
mean.rnase.rep3 <- apply(rnase.rep3z, 1, mean)
```

*Normalization of RNase:*

```{r}
rnase.rep1.meanvalue <- sweep(rnase.rep1z,1,mean.rnase.rep1,'-')
rnase.rep1.zt.norm <- sweep(rnase.rep1.meanvalue,1,sd.rnase,'/')

rnase.rep2.meanvalue <- sweep(rnase.rep2z,1,mean.rnase.rep2,'-')
rnase.rep2.zt.norm <- sweep(rnase.rep2.meanvalue,1,sd.rnase,'/')

rnase.rep3.meanvalue <- sweep(rnase.rep3z,1,mean.rnase.rep3,'-')
rnase.rep3.zt.norm <- sweep(rnase.rep3.meanvalue,1,sd.rnase,'/')

#calculate again the min value for each protein
min.rnase.rep1.zt.norm <- apply(rnase.rep1.zt.norm, 1, min)
min.rnase.rep2.zt.norm <- apply(rnase.rep2.zt.norm, 1, min)
min.rnase.rep3.zt.norm <- apply(rnase.rep3.zt.norm, 1, min)

#substract the min value from each position to discard the 0
rnase.rep1.zt.norm.pos <- sweep(rnase.rep1.zt.norm,1,min.rnase.rep1.zt.norm,FUN = '-')
rnase.rep2.zt.norm.pos <- sweep(rnase.rep2.zt.norm,1,min.rnase.rep2.zt.norm,FUN = '-')
rnase.rep3.zt.norm.pos <- sweep(rnase.rep3.zt.norm,1,min.rnase.rep3.zt.norm,FUN = '-')

```

#### 3.2.2. Scaling

Each Replicate of Ctrl:

```{r}
ctrl.rep1.zt.scaled = 
  sweep(ctrl.rep1.zt.norm.pos,1,100/rowSums(ctrl.rep1.zt.norm.pos),'*')
# rowSums(ctrl.rep1.zt.scaled)
ctrl.rep2.zt.scaled = 
  sweep(ctrl.rep2.zt.norm.pos,1,100/rowSums(ctrl.rep2.zt.norm.pos),'*')
# rowSums(ctrl.rep2.zt.scaled)
ctrl.rep3.zt.scaled = 
  sweep(ctrl.rep3.zt.norm.pos,1,100/rowSums(ctrl.rep3.zt.norm.pos),'*')
# rowSums(ctrl.rep3.zt.scaled)

ctrl.rep.zt.scaled = cbind(ctrl.rep1.zt.scaled,ctrl.rep2.zt.scaled,ctrl.rep3.zt.scaled)
```

Each Replicate of RNAse:

```{r}
rnase.rep1.zt.scaled = 
  sweep(rnase.rep1.zt.norm.pos,1,100/rowSums(rnase.rep1.zt.norm.pos),'*')
# rowSums(rnase.rep1.zt.scaled)
rnase.rep2.zt.scaled = 
  sweep(rnase.rep2.zt.norm.pos,1,100/rowSums(rnase.rep2.zt.norm.pos),'*')
# rowSums(rnase.rep2.zt.scaled)
rnase.rep3.zt.scaled = 
  sweep(rnase.rep3.zt.norm.pos,1,100/rowSums(rnase.rep3.zt.norm.pos),'*')
# rowSums(rnase.rep3.zt.scaled)

rnase.rep.zt.scaled = cbind(rnase.rep1.zt.scaled,rnase.rep2.zt.scaled,rnase.rep3.zt.scaled)
```

#### 3.2.3. Reduction

Now we can set the replicates with poor correlation to NA.

```{r}

for (x in 1:dim(ctrl.rep.zt.scaled)[1]){
  if (ctrl.cor.removed[x, 1] < 0.9) {
    if (ctrl.cor.removed[x, 3] < 0.9){
      ctrl.rep.zt.scaled[x, 1:25] <- NA 
    }
    if (ctrl.cor.removed[x, 2] < 0.9){
      ctrl.rep.zt.scaled[x, 26:50] <- NA
    }}
  
  if (ctrl.cor.removed[x, 3] < 0.9) {
    if (ctrl.cor.removed[x, 2] < 0.9){
      ctrl.rep.zt.scaled[x, 51:75] <- NA
    }
  }
     }

for (x in 1:dim(rnase.rep.zt.scaled)[1]){
  if (rnase.cor.removed[x, 1] < 0.9) {
    if (rnase.cor.removed[x, 3] < 0.9){
      rnase.rep.zt.scaled[x, 1:25] <- NA 
    }
    if (rnase.cor.removed[x, 2] < 0.9){
      rnase.rep.zt.scaled[x, 26:50] <- NA
    }}
  
  if (rnase.cor.removed[x, 3] < 0.9) {
    if (rnase.cor.removed[x, 2] < 0.9){
      rnase.rep.zt.scaled[x, 51:75] <- NA
    }
  }
}


Nr <- c(1:dim(rnase.rep.zt.scaled)[1])
rnase.with.proteinnumbers <- cbind(Nr, rnase.rep.zt.scaled[, 1:25], Nr, rnase.rep.zt.scaled[, 26:50], Nr, rnase.rep.zt.scaled[, 51:75])
View(rnase.with.proteinnumbers)

ctrl.with.proteinnumbers <- cbind(Nr, ctrl.rep[,1:25], Nr, ctrl.rep[,26:50], Nr, ctrl.rep[,51:75])
View(ctrl.with.proteinnumbers)
```

To reduce we take the mean value between each replicate. Here we must consider the NA-values of non-reproducible replicates.

```{r}

r1c <- ctrl.rep1.zt.scaled
r2c <- ctrl.rep2.zt.scaled
r3c <- ctrl.rep3.zt.scaled

r1c0 <- ctrl.rep1.zt.scaled
r2c0 <- ctrl.rep2.zt.scaled
r3c0 <- ctrl.rep3.zt.scaled

r1c0[is.na(r1c)] <- 0
r2c0[is.na(r2c)] <- 0
r3c0[is.na(r3c)] <- 0


ctrl.zt.reduced.ns <-  (r1c0 + r2c0 + r3c0)/(3-((sum(is.na(r1c[x,]) + is.na(r2c[x,]) + is.na(r3c[x,])))/25))
```

```{r}

r1r <- rnase.rep1.zt.scaled
r2r <- rnase.rep2.zt.scaled
r3r <- rnase.rep3.zt.scaled

r1r0 <- rnase.rep1.zt.scaled
r2r0 <- rnase.rep2.zt.scaled
r3r0 <- rnase.rep3.zt.scaled

r1r0[is.na(r1r)] <- 0
r2r0[is.na(r2r)] <- 0
r3r0[is.na(r3r)] <- 0

rnase.zt.reduced.ns <-  (r1r0 + r2r0 + r3r0)/(3-((sum(is.na(r1r[x,]) + is.na(r2r[x,]) + is.na(r3r[x,])))/25))
```

Scaling of the reduced dataset.

```{r}
ctrl.zt.scaled = 
  sweep(ctrl.zt.reduced.ns,1,100/rowSums(ctrl.zt.reduced.ns),'*')
rnase.zt.scaled = 
  sweep(rnase.zt.reduced.ns,1,100/rowSums(rnase.zt.reduced.ns),'*')
```

Now we have normalized/scaled our data using z-transformation. The two variables that will be used later on either contain the normalized and scaled (zt) data of the control: **ctrl.zt** or the normalized and scaled (zt) data of the rnase: **rnase.zt**

```{r}
new.colnames.ctrl <- c("Fraction_1_Ctrl","Fraction_2_Ctrl","Fraction_3_Ctrl","Fraction_4_Ctrl","Fraction_5_Ctrl","Fraction_6_Ctrl","Fraction_7_Ctrl","Fraction_8_Ctrl","Fraction_9_Ctrl","Fraction_10_Ctrl","Fraction_11_Ctrl","Fraction_12_Ctrl","Fraction_13_Ctrl","Fraction_14_Ctrl","Fraction_15_Ctrl","Fraction_16_Ctrl","Fraction_17_Ctrl","Fraction_18_Ctrl","Fraction_19_Ctrl","Fraction_20_Ctrl","Fraction_21_Ctrl","Fraction_22_Ctrl","Fraction_23_Ctrl","Fraction_24_Ctrl","Fraction_25_Ctrl")
new.colnames.rnase <- c("Fraction_1_RNase","Fraction_2_RNase","Fraction_3_RNase","Fraction_4_RNase","Fraction_5_RNase","Fraction_6_RNase","Fraction_7_RNase","Fraction_8_RNase","Fraction_9_RNase","Fraction_10_RNase","Fraction_11_RNase","Fraction_12_RNase","Fraction_13_RNase","Fraction_14_RNase","Fraction_15_RNase","Fraction_16_RNase","Fraction_17_RNase","Fraction_18_RNase","Fraction_19_RNase","Fraction_20_RNase","Fraction_21_RNase","Fraction_22_RNase","Fraction_23_RNase","Fraction_24_RNase","Fraction_25_RNase")

ctrl.zt <- ctrl.zt.scaled
colnames(ctrl.zt) <- new.colnames.ctrl

rnase.zt <- rnase.zt.scaled
colnames(rnase.zt) <- new.colnames.rnase

# View(ctrl.zt)
# View(rnase.zt)
```

### 3.3. Min-Max-Scaling

#### 3.3.1. Normalization

We perform min-max-scaling (mms) on each replicate, both control and RNase:

```{r}

# Control Replicate 1 MMS
ctrl.rep1.mms.norm <- t(apply(ctrl.rep1, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# Control Replicate 2 MMS
ctrl.rep2.mms.norm <- t(apply(ctrl.rep2, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# Control Replicate 3 MMS
ctrl.rep3.mms.norm <- t(apply(ctrl.rep3, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# RNase Replicate 1 MMS
rnase.rep1.mms.norm <- t(apply(rnase.rep1, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# RNase Replicate 2 MMS
rnase.rep2.mms.norm <- t(apply(rnase.rep2, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# RNase Replicate 2 MMS
rnase.rep3.mms.norm <- t(apply(rnase.rep3, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))
```

To prove that the algorithm works we use is on a test matrix:

```{r}
test_matrix <- matrix(c(1,45,3,8,27,4,79,30,0,100,99,50,0,76,1,4,6,3,8,7,3), byrow = TRUE, nrow = 3)

test_normalized <- t(apply(test_matrix, 1, function(x){
  normalized <- (x-min(x))/(max(x)-min(x))
}))

#test_matrix
#test_normalized
```

#### 3.3.2. Reduction

To reduce we take the mean value between each replicate. Here we must consider the NA-values of non-reproducible replicates.

```{r}

r1c <- ctrl.rep1.mms.norm
r2c <- ctrl.rep2.mms.norm
r3c <- ctrl.rep3.mms.norm

r1c0 <- ctrl.rep1.mms.norm
r2c0 <- ctrl.rep2.mms.norm
r3c0 <- ctrl.rep3.mms.norm

r1c0[is.na(r1c)] <- 0
r2c0[is.na(r2c)] <- 0
r3c0[is.na(r3c)] <- 0

ctrl.mms.reduced <-  (r1c0 + r2c0 + r3c0)/(3-((sum(as.numeric(is.na(r1c[x,])) + as.numeric(is.na(r2c[x,])) + as.numeric(is.na(r3c[x,]))))/25))


#View(ctrl.mms.reduced)
```

```{r}

r1r <- rnase.rep1.mms.norm
r2r <- rnase.rep2.mms.norm
r3r <- rnase.rep3.mms.norm

r1r0 <- rnase.rep1.mms.norm
r2r0 <- rnase.rep2.mms.norm
r3r0 <- rnase.rep3.mms.norm

r1r0[is.na(r1r)] <- 0
r2r0[is.na(r2r)] <- 0
r3r0[is.na(r3r)] <- 0

rnase.mms.reduced <-  (r1r0 + r2r0 + r3r0)/(3 - ((sum(as.numeric(is.na(r1r[x,])) + as.numeric(is.na(r2r[x,])) + as.numeric(is.na(r3r[x,]))))/25))
                        

#View(rnase.mms.reduced)
```

#### 3.3.3. Scaling

Those have to be scaled again:

```{r}
ctrl.mms.scaled <- t(apply(ctrl.mms.reduced, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

rnase.mms.scaled <- t(apply(rnase.mms.reduced, 1, function(x){
  normalized <- (x-min(x))/(max(x)-min(x))
}))
```

Now we can plot graphs that show the result of the merge and second scaling. This is only an example (RNase sample of the first protein), the plotting of all proteins will be done later on:

```{r}
##plots of the scaled replicates

plot(rnase.rep1.mms.norm[1,], xlab="fraction", ylab="protein amount", col="green", pch=20)
plot(rnase.rep2.mms.norm[1,], xlab="fraction", ylab="protein amount", col="green", pch=20)
#plot(rnase.rep3.mms.norm[1,], xlab="fraction", ylab="protein amount", col="green", pch=20)

##plot of the merged ctrl

plot(rnase.mms.reduced[1,], xlab="fraction", ylab="protein amount", col="red", pch=20)

##plot of the merged and scaled ctrl
plot(rnase.mms.scaled[1,], xlab="fraction", ylab="protein amount", col="blue", pch=20)
```

Now we have normalized/scaled our data using min-max-scaling. The two variables that will be used later on either contain the normalized/scaled (mms) of the control: **ctrl.mms** or the normalized/scaled (mms) and scaled data of the rnase: **rnase.mms**

```{r}
new.colnames.ctrl <- c("Fraction_1_Ctrl","Fraction_2_Ctrl","Fraction_3_Ctrl","Fraction_4_Ctrl","Fraction_5_Ctrl","Fraction_6_Ctrl","Fraction_7_Ctrl","Fraction_8_Ctrl","Fraction_9_Ctrl","Fraction_10_Ctrl","Fraction_11_Ctrl","Fraction_12_Ctrl","Fraction_13_Ctrl","Fraction_14_Ctrl","Fraction_15_Ctrl","Fraction_16_Ctrl","Fraction_17_Ctrl","Fraction_18_Ctrl","Fraction_19_Ctrl","Fraction_20_Ctrl","Fraction_21_Ctrl","Fraction_22_Ctrl","Fraction_23_Ctrl","Fraction_24_Ctrl","Fraction_25_Ctrl")
new.colnames.rnase <- c("Fraction_1_RNase","Fraction_2_RNase","Fraction_3_RNase","Fraction_4_RNase","Fraction_5_RNase","Fraction_6_RNase","Fraction_7_RNase","Fraction_8_RNase","Fraction_9_RNase","Fraction_10_RNase","Fraction_11_RNase","Fraction_12_RNase","Fraction_13_RNase","Fraction_14_RNase","Fraction_15_RNase","Fraction_16_RNase","Fraction_17_RNase","Fraction_18_RNase","Fraction_19_RNase","Fraction_20_RNase","Fraction_21_RNase","Fraction_22_RNase","Fraction_23_RNase","Fraction_24_RNase","Fraction_25_RNase")

ctrl.mms <- ctrl.mms.scaled
colnames(ctrl.mms) <- new.colnames.ctrl
rnase.mms <- rnase.mms.scaled
colnames(rnase.mms) <- new.colnames.rnase

# View(ctrl.mms)
# View(rnase.mms)
```

The result of this part are three times (Methods) two (Ctrl and RNase) normalized and scaled data frames: **ctrl.mvm**, **rnase.mvm**, **ctrl.zt**, **rnase.zt**, **ctrl.mms**, **rnase.mms**

Safe the normalized data:

```{r}
saveRDS(ctrl.mvm, file = "Non_synchronized_A549_ctrl.mvm")
saveRDS(rnase.mvm, file = "Non_synchronized_A549_rnase.mvm")

saveRDS(ctrl.zt, file = "Non_synchronized_A549_ctrl.zt")
saveRDS(rnase.zt, file = "Non_synchronized_A549_rnase.zt")

saveRDS(ctrl.mms, file = "Non_synchronized_A549_ctrl.mms")
saveRDS(rnase.mms, file = "Non_synchronized_A549_rnase.mms")
```

## 4. Line Graph

```{r}
ctrl.mvm <- readRDS("Non_synchronized_A549_ctrl.mvm")
rnase.mvm <- readRDS("Non_synchronized_A549_rnase.mvm")

ctrl.zt <- readRDS("Non_synchronized_A549_ctrl.zt")
rnase.zt <- readRDS("Non_synchronized_A549_rnase.zt")

ctrl.mms <- readRDS("Non_synchronized_A549_ctrl.mms")
rnase.mms <- readRDS("Non_synchronized_A549_rnase.mms")
```

### 4.1. Line Graphs for the mean value method - normalization

We start by plotting the amount of each protein in the 25 fractions for the RNase group.

```{r}
library(ggplot2)

num_rows <- nrow(rnase.mvm)

plots_rnase.mvm <- list()

for (i in 1:num_rows) {
  row_data_rnase <- rnase.mvm[i, ]
  
   if (sum(!is.na(row_data_rnase)) >= 2) {
    df <- data.frame(x = 1:length(row_data_rnase), yrnase = as.numeric(row_data_rnase))
    
        p <- ggplot(df, aes(x = x, y = yrnase)) +
      geom_line(color = "tomato") +
      geom_point(color = "tomato") +
      xlab("Fractions") +
      ylab("Protein amount")+
      labs(title = "RNase MVM")
    
    
    
    plots_rnase.mvm[[i]] <- p
  } else {
    
    plots_rnase.mvm[[i]] <- NULL
  }
}

```

Next we create the plots for the Control group.

```{r}
library(ggplot2)

num_rows <- nrow(ctrl.mvm)

plots_ctrl.mvm <- list()

for (i in 1:num_rows) {
  row_data_ctrl <- ctrl.mvm[i, ]
  
    if (sum(!is.na(row_data_ctrl)) >= 2) {
    df <- data.frame(x = 1:length(row_data_ctrl), yctrl = as.numeric(row_data_ctrl))
    
    # Erstelle den Plot mit ggplot2 
    p <- ggplot(df, aes(x = x, y = yctrl)) +
      geom_line(color = "skyblue2") +
      geom_point(color = "skyblue2") +
      xlab("Fractions") +
      ylab("Protein amount") +
      labs(title = "Control MVM")
    
    
    
    plots_ctrl.mvm[[i]] <- p
  } else {
    
    plots_ctrl.mvm[[i]] <- NULL
  }
}
```

The following code creates two plots in one diagram, so that the Control and RNase group can be compared.

```{r}
library(ggplot2)

num_rows <- nrow(ctrl.mvm)

names.as.colum <- ctrl.mvm
protein.names <- rownames(names.as.colum)

plots_ctrl_rnase.mvm <- list()

for (i in 1:num_rows) {
  row_data_ctrl <- ctrl.mvm[i, ]
  row_data_rnase <- rnase.mvm[i, ]
  
  if (sum(!is.na(row_data_ctrl)) >= 2) {
    df <- data.frame(x = 1:length(row_data_ctrl),yctrl= as.numeric(row_data_ctrl),yrnase= as.numeric(row_data_rnase))

    
    
    p <- ggplot(df, aes(x = x))+
      geom_line(aes(y=yrnase,color="RNASE"))+
      geom_point(aes(y=yrnase,color="RNASE"))+
      geom_line(aes(y=yctrl, color="CTRL"))+
      geom_point(aes(y=yctrl, color="CTRL"))+
      xlab("Fractions") +
      ylab("Protein amount") +
      labs(title = paste("Mean Value Method -",protein.names[i]))+
      scale_color_manual(values = c("RNASE" = "tomato", "CTRL" = "skyblue2"))
    
    
    
    plots_ctrl_rnase.mvm[[i]] <- p
  } else {
     
    plots_ctrl_rnase.mvm[[i]] <- NULL
  }
}
```

Damit der richtige Name ausgespuckt wird, muss der Code drüber immer neu geladen werden!

```{r}
# print( plots_ctrl_rnase.mvm[[6]])
```

### 4.2. Line Graphs for the z_transformation - normalization

We start by plotting the amount of each protein in the 25 fractions for the RNase group.

```{r}
library(ggplot2)

num_rows <- nrow(rnase.zt)

plots_rnase.zt <- list()

for (i in 1:num_rows) {
  row_data_rnase <- rnase.zt[i, ]
  
  
   if (sum(!is.na(row_data_rnase)) >= 2) {
    df <- data.frame(x = 1:length(row_data_rnase), yrnase = as.numeric(row_data_rnase))
    
      p <- ggplot(df, aes(x = x, y = yrnase)) +
      geom_line(color = "tomato") +
      geom_point(color = "tomato") +
      xlab("Fractions") +
      ylab("Protein amount") +
      labs(title = "RNase zT")
      
    
    plots_rnase.zt[[i]] <- p
  } else {
    
    plots_rnase.zt[[i]] <- NULL
  }
}
```

Next we create the plots for the Control group.

```{r}
library(ggplot2)

num_rows <- nrow(ctrl.zt)

plots_ctrl.zt <- list()

for (i in 1:num_rows) {
  row_data_ctrl <- ctrl.zt[i, ]
  
    if (sum(!is.na(row_data_ctrl)) >= 2) {
    df <- data.frame(x = 1:length(row_data_ctrl), yctrl = as.numeric(row_data_ctrl))
    
      p <- ggplot(df, aes(x = x, y = yctrl)) +
      geom_line(color = "skyblue2") +
      geom_point(color = "skyblue2") +
      xlab("Fractions") +
      ylab("Protein amount") +
      labs(title = "Control zT")
    
    
    plots_ctrl.zt[[i]] <- p
  } else {
    
    plots_ctrl.zt[[i]] <- NULL
  }
}
```

The following code creates two plots in one diagram, so that the Control and RNase group can be compared.

```{r}
library(ggplot2)

num_rows <- nrow(ctrl.zt)

names.as.colum <- ctrl.zt
protein.names <- rownames(names.as.colum)

plots_ctrl_rnase.zt <- list()

for (i in 1:num_rows) {
  row_data_ctrl <- ctrl.zt[i, ]
  row_data_rnase <- rnase.zt[i, ]
  
  if (sum(!is.na(row_data_ctrl)) >= 2) {
    df <- data.frame(x = 1:length(row_data_ctrl),yctrl= as.numeric(row_data_ctrl),yrnase= as.numeric(row_data_rnase))
    
    
    p <- ggplot(df, aes(x = x))+
      geom_line(aes(y=yrnase,color="RNASE"))+
      geom_point(aes(y=yrnase,color="RNASE"))+
      geom_line(aes(y=yctrl, color="CTRL"))+
      geom_point(aes(y=yctrl, color="CTRL"))+
      xlab("Fractions") +
      ylab("Protein amount") +
      labs(title = paste("z Transformation -",protein.names[i])) +
      scale_color_manual(values = c("RNASE" = "tomato", "CTRL" = "skyblue2"))
    
    
    
    plots_ctrl_rnase.zt[[i]] <- p
  } else {
     
    plots_ctrl_rnase.zt[[i]] <- NULL
  }
}
```

Damit der richtige Name ausgespuckt wird, muss der Code drüber immer neu geladen werden!

```{r}
# print(plots_ctrl_rnase.zt[[7]])
```

### 4.3. Line Graphs for the min - max - scaling

We start by plotting the amount of each protein in the 25 fractions for the RNase group.

```{r}
library(ggplot2)

num_rows <- nrow(rnase.mms)

plots_rnase.mms <- list()

for (i in 1:num_rows) {
  row_data_rnase <- rnase.mms[i, ]
  
   if (sum(!is.na(row_data_rnase)) >= 2) {
    df <- data.frame(x = 1:length(row_data_rnase), yrnase = as.numeric(row_data_rnase))
    
      p <- ggplot(df, aes(x = x, y = yrnase)) +
      geom_line(color = "tomato") +
      geom_point(color = "tomato") +
      xlab("Fractions") +
      ylab("Protein amount")+
      labs(title = "RNase MMS")
    
    
    plots_rnase.mms[[i]] <- p
  } else {
    
    plots_rnase.mms[[i]] <- NULL
  }
}
```

Next we create the plots for the Control group.

```{r}
library(ggplot2)

num_rows <- nrow(ctrl.mms)

plots_ctrl.mms <- list()

for (i in 1:num_rows) {
  row_data_ctrl <- ctrl.mms[i, ]
  
    if (sum(!is.na(row_data_ctrl)) >= 2) {
    df <- data.frame(x = 1:length(row_data_ctrl), yctrl = as.numeric(row_data_ctrl))
    
      p <- ggplot(df, aes(x = x, y = yctrl)) +
      geom_line(color = "skyblue2") +
      geom_point(color = "skyblue2") +
      xlab("Fractions") +
      ylab("Protein amount") +
      labs(title = "Control MMS")

    
    plots_ctrl.mms[[i]] <- p
  } else {
    
    plots_ctrl.mms[[i]] <- NULL
  }
}
```

The following code creates two plots in one diagram, so that the Control and RNase group can be compared.

```{r}
library(ggplot2)

num_rows <- nrow(ctrl.mms)

names.as.colum <- ctrl.mms
protein.names <- rownames(names.as.colum)

plots_ctrl_rnase.mms <- list()

for (i in 1:num_rows) {
  row_data_ctrl <- ctrl.mms[i, ]
  row_data_rnase <- rnase.mms[i, ]
  
  if (sum(!is.na(row_data_ctrl)) >= 2) {
    df <- data.frame(x = 1:length(row_data_ctrl),yctrl= as.numeric(row_data_ctrl),yrnase= as.numeric(row_data_rnase))
    
    
    p <- ggplot(df, aes(x = x))+
      geom_line(aes(y=yrnase,color="RNASE"))+
      geom_point(aes(y=yrnase,color="RNASE"))+
      geom_line(aes(y=yctrl, color="CTRL"))+
      geom_point(aes(y=yctrl, color="CTRL"))+
      xlab("Fractions") +
      ylab("Protein amount") +
      labs(title = paste("Min Max Scaling -",protein.names[i])) +
      scale_color_manual(values = c("RNASE" = "tomato", "CTRL" = "skyblue2"))
    
    
    
    plots_ctrl_rnase.mms[[i]] <- p
  } else {
     
    plots_ctrl_rnase.mms[[i]] <- NULL
  }
}
```

Damit der richtige Name ausgespuckt wird, muss der Code drüber immer neu geladen werden!

```{r}
# print(plots_ctrl_rnase.mms[[7]])
```

## 5. Peak Identification

```{r}
ctrl.mvm <- readRDS("Non_synchronized_A549_ctrl.mvm")
rnase.mvm <- readRDS("Non_synchronized_A549_rnase.mvm")

ctrl.zt <- readRDS("Non_synchronized_A549_ctrl.zt")
rnase.zt <- readRDS("Non_synchronized_A549_rnase.zt")

ctrl.mms <- readRDS("Non_synchronized_A549_ctrl.mms")
rnase.mms <- readRDS("Non_synchronized_A549_rnase.mms")
```

### 5.1. Peaks for data set with mean value method - normalization

#### 5.1.1. Global Peak

First the global peak identification for the control data set. We calculate the fraction and the protein amount under the global peak. Second we do the same for the rnase data set.

```{r}
globalpeak.ctrl.mvm <- apply(ctrl.mvm, 1, function(x){which.max(x)})
globalpeak.value.ctrl.mvm <- apply(ctrl.mvm, 1, function(x){max(x)})

globalpeak.rnase.mvm <- apply(rnase.mvm, 1, function(x){which.max(x)})
globalpeak.value.rnase.mvm <- apply(rnase.mvm, 1, function(x){max(x)})
```

#### 5.1.2. Local Peaks

First we have to calculate all the peaks, meaning global and local. We start again with the ctrl group. We start with calculating the sd to later sort out small fluctuations.

```{r}
peakidentif.ctrl.mvm <- ctrl.mvm
peakidentif.rnase.mvm <- rnase.mvm

sd.byrow.ctrl.mvm <- apply(peakidentif.ctrl.mvm, 1, function(x) sd(x[x < 8]))
sd.mean.ctrl.mvm <- mean(sd.byrow.ctrl.mvm)
sd.byrow.rnase.mvm <- apply(peakidentif.rnase.mvm, 1, function(x) sd(x[x < 8]))
sd.mean.rnase.mvm <- mean(sd.byrow.rnase.mvm)
```

Now we give the fractions new names. Thereby we take into regard that the length of peak_indices is shorter than the length of each row of our normalized data set. Afterwards we calculate each peak and look which did not occur as global peaks to identify the local peaks. Again starting with the control data set.

```{r}
colnames(peakidentif.ctrl.mvm) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.ctrl.mvm)) - 1)

allpeaks.ctrl.mvm <- apply(peakidentif.ctrl.mvm, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.ctrl.mvm]})

peak.values.ctrl.mvm <- lapply(seq_along(allpeaks.ctrl.mvm), function(i) peakidentif.ctrl.mvm[i, allpeaks.ctrl.mvm[[i]]])

localpeaks.ctrl.mvm <- allpeaks.ctrl.mvm 
for (i in seq_along(localpeaks.ctrl.mvm)) {localpeaks.ctrl.mvm[[i]] <- localpeaks.ctrl.mvm[[i]][!localpeaks.ctrl.mvm[[i]] %in% globalpeak.ctrl.mvm[[i]]]}

localpeaks.values.ctrl.mvm <- lapply(seq_along(localpeaks.ctrl.mvm), function(i) peakidentif.ctrl.mvm[i, localpeaks.ctrl.mvm[[i]]])
```

```{r}
colnames(peakidentif.rnase.mvm) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.rnase.mvm)) - 1)

allpeaks.rnase.mvm <- apply(peakidentif.rnase.mvm, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.rnase.mvm]})

peak.values.rnase.mvm <- lapply(seq_along(allpeaks.rnase.mvm), function(i) peakidentif.rnase.mvm[i, allpeaks.rnase.mvm[[i]]])

localpeaks.rnase.mvm <- allpeaks.rnase.mvm 
for (i in seq_along(localpeaks.rnase.mvm)) {localpeaks.rnase.mvm[[i]] <- localpeaks.rnase.mvm[[i]][!localpeaks.rnase.mvm[[i]] %in% globalpeak.rnase.mvm[[i]]]}

localpeaks.values.rnase.mvm <- lapply(seq_along(localpeaks.rnase.mvm), function(i) peakidentif.rnase.mvm[i, localpeaks.rnase.mvm[[i]]])
```

#### 5.1.3. Boundaries

Futhermore, we have to look if there are peaks in fraction 1 or fraction 25. Again, we start with the identification of the boundaries for the control group.

```{r}
fraction1.peak.ctrl.mvm <- which(peakidentif.ctrl.mvm[, 1] > peakidentif.ctrl.mvm[, 2] & peakidentif.ctrl.mvm[, 1] > peakidentif.ctrl.mvm[, 3])
# length(fraction1.peak.ctrl.mvm)

fraction25.peak.ctrl.mvm <- which(peakidentif.ctrl.mvm[, 25] > peakidentif.ctrl.mvm[, 24] & peakidentif.ctrl.mvm[, 25] > peakidentif.ctrl.mvm[, 23] & peakidentif.ctrl.mvm[, 25] + peakidentif.ctrl.mvm[, 24] +peakidentif.ctrl.mvm[, 23] > 10) # wenn der peak am Ende nicht insgesamt 10 überschreitet, ist es relativ unrelevant. Scheinbar fallen viele Proteine am Ende etwas aus.
# length(fraction25.peak.ctrl.mvm)
```

```{r}
fraction1.peak.rnase.mvm <- which(peakidentif.rnase.mvm[, 1] > peakidentif.rnase.mvm[, 2] & peakidentif.rnase.mvm[, 1] > peakidentif.rnase.mvm[, 3])
# length(fraction1.peak.rnase.mvm)

fraction25.peak.rnase.mvm <- which(peakidentif.rnase.mvm[, 25] > peakidentif.rnase.mvm[, 24] & peakidentif.rnase.mvm[, 25] > peakidentif.rnase.mvm[, 23] & peakidentif.rnase.mvm[, 25] + peakidentif.rnase.mvm[, 24] + peakidentif.rnase.mvm[, 23] > 10)
# length(fraction25.peak.rnase.mvm)
```

#### 5.1.4. Precipitated Proteins

At last we identify the precipitated proteins:

```{r}
precipitated.ctrl.mvm <- which(peakidentif.ctrl.mvm[, 25] > peakidentif.ctrl.mvm[, 24] & peakidentif.ctrl.mvm[, 25] > peakidentif.ctrl.mvm[, 23] & peakidentif.ctrl.mvm[, 25] + peakidentif.ctrl.mvm[, 24] + peakidentif.ctrl.mvm[, 23] == 100)

precipitated.rnase.mvm <- which(peakidentif.rnase.mvm[, 25] > peakidentif.rnase.mvm[, 24] & peakidentif.rnase.mvm[, 25] > peakidentif.rnase.mvm[, 23] & peakidentif.rnase.mvm[, 25] + peakidentif.rnase.mvm[, 24] + peakidentif.rnase.mvm[, 23] == 100)

precipitated.mvm <- unique(c(precipitated.ctrl.mvm,precipitated.rnase.mvm))
```

### 5.2. Peaks for data set with z_transformation - normalization

#### 5.2.1. Global Peak

First the global peak identification for the control data set. We calculate the fraction and the protein amount under the global peak. Second we do the same for the rnase data set.

```{r}
globalpeak.ctrl.zt <- apply(ctrl.zt, 1, function(x){which.max(x)})
globalpeak.value.ctrl.zt <- apply(ctrl.zt, 1, function(x){max(x)})

globalpeak.rnase.zt <- apply(rnase.zt, 1, function(x){which.max(x)})
globalpeak.value.rnase.zt <- apply(rnase.zt, 1, function(x){max(x)})
```

#### 5.2.2. Local Peaks

First we have to calculate all the peaks, meaning global and local. We start again with the ctrl group. We start with calculating the sd to later sort out small fluctuations.

```{r}
peakidentif.ctrl.zt <- ctrl.zt
peakidentif.rnase.zt <- rnase.zt

sd.byrow.ctrl.zt <- apply(peakidentif.ctrl.zt, 1, function(x) sd(x[x < 8]))
sd.mean.ctrl.zt <- mean(sd.byrow.ctrl.zt)
sd.byrow.rnase.zt <- apply(peakidentif.rnase.zt, 1, function(x) sd(x[x < 8]))
sd.mean.rnase.zt <- mean(sd.byrow.rnase.zt)
```

Now we give the fractions new names. Thereby we take into regard that the length of peak_indices is shorter than the length of each row of our normalized data set. Afterwards we calculate each peak and look which did not occur as global peaks to identify the local peaks. Again starting with the control data set.

```{r}
colnames(peakidentif.ctrl.zt) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.ctrl.zt)) - 1)

allpeaks.ctrl.zt <- apply(peakidentif.ctrl.zt, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.ctrl.zt]})

peak.values.ctrl.zt <- lapply(seq_along(allpeaks.ctrl.zt), function(i) peakidentif.ctrl.zt[i, allpeaks.ctrl.zt[[i]]])

localpeaks.ctrl.zt <- allpeaks.ctrl.zt 
for (i in seq_along(localpeaks.ctrl.zt)) {localpeaks.ctrl.zt[[i]] <- localpeaks.ctrl.zt[[i]][!localpeaks.ctrl.zt[[i]] %in% globalpeak.ctrl.zt[[i]]]}

localpeaks.values.ctrl.zt <- lapply(seq_along(localpeaks.ctrl.zt), function(i) peakidentif.ctrl.zt[i, localpeaks.ctrl.zt[[i]]])
```

```{r}
colnames(peakidentif.rnase.zt) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.rnase.zt)) - 1)

allpeaks.rnase.zt <- apply(peakidentif.rnase.zt, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.rnase.zt]})

peak.values.rnase.zt <- lapply(seq_along(allpeaks.rnase.zt), function(i) peakidentif.rnase.zt[i, allpeaks.rnase.zt[[i]]])

localpeaks.rnase.zt <- allpeaks.rnase.zt
for (i in seq_along(localpeaks.rnase.zt)) {localpeaks.rnase.zt[[i]] <- localpeaks.rnase.zt[[i]][!localpeaks.rnase.zt[[i]] %in% globalpeak.rnase.zt[[i]]]}

localpeaks.values.rnase.zt <- lapply(seq_along(localpeaks.rnase.zt), function(i) peakidentif.rnase.zt[i, localpeaks.rnase.zt[[i]]])
```

#### 5.2.3. Boundaries

Futhermore, we have to look if there are peaks in fraction 1 or fraction 25. Again, we start with the identification of the boundaries for the control group.

```{r}
fraction1.peak.ctrl.zt <- which(peakidentif.ctrl.zt[, 1] > peakidentif.ctrl.zt[, 2] & peakidentif.ctrl.zt[, 1] > peakidentif.ctrl.zt[, 3])
# length(fraction1.peak.ctrl.zt)

fraction25.peak.ctrl.zt <- which(peakidentif.ctrl.zt[, 25] > peakidentif.ctrl.zt[, 24] & peakidentif.ctrl.zt[, 25] > peakidentif.ctrl.zt[, 23] & peakidentif.ctrl.zt[, 25] + peakidentif.ctrl.zt[, 24] +peakidentif.ctrl.zt[, 23] > 10) # wenn der peak am Ende nicht insgesamt 10 überschreitet, ist es relativ unrelevant. Scheinbar fallen viele Proteine am Ende etwas aus.
# length(fraction25.peak.ctrl.zt)
```

```{r}
fraction1.peak.rnase.zt <- which(peakidentif.rnase.zt[, 1] > peakidentif.rnase.zt[, 2] & peakidentif.rnase.zt[, 1] > peakidentif.rnase.zt[, 3])
# length(fraction1.peak.rnase.zt)

fraction25.peak.rnase.zt <- which(peakidentif.rnase.zt[, 25] > peakidentif.rnase.zt[, 24] & peakidentif.rnase.zt[, 25] > peakidentif.rnase.zt[, 23] & peakidentif.rnase.zt[, 25] + peakidentif.rnase.zt[, 24] + peakidentif.rnase.zt[, 23] > 10)
# length(fraction25.peak.rnase.zt)
```

#### 5.2.4. Precipitated Proteins

At last we identify the precipitated proteins:

```{r}
precipitated.ctrl.zt <- which(peakidentif.ctrl.zt[, 25] > peakidentif.ctrl.zt[, 24] & peakidentif.ctrl.zt[, 25] > peakidentif.ctrl.zt[, 23] & peakidentif.ctrl.zt[, 25] + peakidentif.ctrl.zt[, 24] + peakidentif.ctrl.zt[, 23] == 100)

precipitated.rnase.zt <- which(peakidentif.rnase.zt[, 25] > peakidentif.rnase.zt[, 24] & peakidentif.rnase.zt[, 25] > peakidentif.rnase.zt[, 23] & peakidentif.rnase.zt[, 25] + peakidentif.rnase.zt[, 24] + peakidentif.rnase.zt[, 23] == 100)

precipitated.zt <- unique(c(precipitated.ctrl.zt,precipitated.rnase.zt))
```

### 5.3. Peaks for data set with min - max - scaling

#### 5.3.1. Global Peak

First the global peak identification for the control data set. We calculate the fraction and the protein amount under the global peak. Second we do the same for the rnase data set.

```{r}
globalpeak.ctrl.mms <- apply(ctrl.mms, 1, function(x){which.max(x)})
globalpeak.value.ctrl.mms <- apply(ctrl.mms, 1, function(x){max(x)})

globalpeak.rnase.mms <- apply(rnase.mms, 1, function(x){which.max(x)})
globalpeak.value.rnase.mms <- apply(rnase.mms, 1, function(x){max(x)})
```

#### 5.3.2. Local Peaks

First we have to calculate all the peaks, meaning global and local. We start again with the ctrl group. We start with calculating the sd to later sort out small fluctuations.

```{r}
peakidentif.ctrl.mms <- ctrl.mms
peakidentif.rnase.mms <- rnase.mms

sd.byrow.ctrl.mms <- apply(peakidentif.ctrl.mms, 1, function(x) sd(x[x < 8]))
sd.mean.ctrl.mms <- mean(sd.byrow.ctrl.mms)
sd.byrow.rnase.mms <- apply(peakidentif.rnase.mms, 1, function(x) sd(x[x < 8]))
sd.mean.rnase.mms <- mean(sd.byrow.rnase.mms)
```

Now we give the fractions new names. Thereby we take into regard that the length of peak_indices is shorter than the length of each row of our normalized data set. Afterwards we calculate each peak and look which did not occur as global peaks to identify the local peaks. Again starting with the control data set.

```{r}
colnames(peakidentif.ctrl.mms) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.ctrl.mms)) - 1)

allpeaks.ctrl.mms <- apply(peakidentif.ctrl.mms, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.ctrl.mms]})

peak.values.ctrl.mms <- lapply(seq_along(allpeaks.ctrl.mms), function(i) peakidentif.ctrl.mms[i, allpeaks.ctrl.mms[[i]]])

localpeaks.ctrl.mms <- allpeaks.ctrl.mms 
for (i in seq_along(localpeaks.ctrl.mms)) {localpeaks.ctrl.mms[[i]] <- localpeaks.ctrl.mms[[i]][!localpeaks.ctrl.mms[[i]] %in% globalpeak.ctrl.mms[[i]]]}

localpeaks.values.ctrl.mms <- lapply(seq_along(localpeaks.ctrl.mms), function(i) peakidentif.ctrl.mms[i, localpeaks.ctrl.mms[[i]]])
```

```{r}
colnames(peakidentif.rnase.mms) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.rnase.mms)) - 1)

allpeaks.rnase.mms <- apply(peakidentif.rnase.mms, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.rnase.mms]})

peak.values.rnase.mms <- lapply(seq_along(allpeaks.rnase.mms), function(i) peakidentif.rnase.mms[i, allpeaks.rnase.mms[[i]]])

localpeaks.rnase.mms <- allpeaks.rnase.mms
for (i in seq_along(localpeaks.rnase.mms)) {localpeaks.rnase.mms[[i]] <- localpeaks.rnase.mms[[i]][!localpeaks.rnase.mms[[i]] %in% globalpeak.rnase.mms[[i]]]}

localpeaks.values.rnase.mms <- lapply(seq_along(localpeaks.rnase.mms), function(i) peakidentif.rnase.mms[i, localpeaks.rnase.mms[[i]]])
```

#### 5.3.3. Boundaries

Futhermore, we have to look if there are peaks in fraction 1 or fraction 25. Again, we start with the identification of the boundaries for the control group.

```{r}
fraction1.peak.ctrl.mms <- which(peakidentif.ctrl.mms[, 1] > peakidentif.ctrl.mms[, 2] & peakidentif.ctrl.mms[, 1] > peakidentif.ctrl.mms[, 3])
# length(fraction1.peak.ctrl.mms)

fraction25.peak.ctrl.mms <- which(peakidentif.ctrl.mms[, 25] > peakidentif.ctrl.mms[, 24] & peakidentif.ctrl.mms[, 25] > peakidentif.ctrl.mms[, 23] & peakidentif.ctrl.mms[, 25] + peakidentif.ctrl.mms[, 24] +peakidentif.ctrl.mms[, 23] > 10) # wenn der peak am Ende nicht insgesamt 10 überschreitet, ist es relativ unrelevant. Scheinbar fallen viele Proteine am Ende etwas aus.
# length(fraction25.peak.ctrl.mms)
```

```{r}
fraction1.peak.rnase.mms <- which(peakidentif.rnase.mms[, 1] > peakidentif.rnase.mms[, 2] & peakidentif.rnase.mms[, 1] > peakidentif.rnase.mms[, 3])
# length(fraction1.peak.rnase.mms)

fraction25.peak.rnase.mms <- which(peakidentif.rnase.mms[, 25] > peakidentif.rnase.mms[, 24] & peakidentif.rnase.mms[, 25] > peakidentif.rnase.mms[, 23] & peakidentif.rnase.mms[, 25] + peakidentif.rnase.mms[, 24] + peakidentif.rnase.mms[, 23] > 10)
# length(fraction25.peak.rnase.mms)
```

#### 5.3.4. Precipitated Proteins

At last we identify the precipitated proteins:

```{r}
precipitated.ctrl.mms <- which(peakidentif.ctrl.mms[, 25] > peakidentif.ctrl.mms[, 24] & peakidentif.ctrl.mms[, 25] > peakidentif.ctrl.mms[, 23] & peakidentif.ctrl.mms[, 25] + peakidentif.ctrl.mms[, 24] + peakidentif.ctrl.mms[, 23] == 100)

precipitated.rnase.mms <- which(peakidentif.rnase.mms[, 25] > peakidentif.rnase.mms[, 24] & peakidentif.rnase.mms[, 25] > peakidentif.rnase.mms[, 23] & peakidentif.rnase.mms[, 25] + peakidentif.rnase.mms[, 24] + peakidentif.rnase.mms[, 23] == 100)

precipitated.mms <- unique(c(precipitated.ctrl.mms,precipitated.rnase.mms))
```

Save all relevant data:

```{r}
# mvm
saveRDS(sd.mean.ctrl.mvm, file = "Non_synchronized_A549_sd.mean.ctrl.mvm ")
saveRDS(sd.mean.rnase.mvm , file = "Non_synchronized_A549_sd.mean.rnase.mvm")

saveRDS(globalpeak.ctrl.mvm, file = "Non_synchronized_A549_globalpeak.ctrl.mvm")
saveRDS(globalpeak.value.ctrl.mvm, file = "Non_synchronized_A549_globalpeak.value.ctrl.mvm")

saveRDS(globalpeak.rnase.mvm, file = "Non_synchronized_A549_globalpeak.rnase.mvm")
saveRDS(globalpeak.value.rnase.mvm, file = "Non_synchronized_A549_globalpeak.value.rnase.mvm")

saveRDS(localpeaks.ctrl.mvm, file = "Non_synchronized_A549_localpeaks.ctrl.mvm")
saveRDS(localpeaks.values.ctrl.mvm, file = "Non_synchronized_A549_localpeaks.values.ctrl.mvm")

saveRDS(localpeaks.rnase.mvm, file = "Non_synchronized_A549_localpeaks.rnase.mvm")
saveRDS(localpeaks.values.rnase.mvm, file = "Non_synchronized_A549_localpeaks.values.rnase.mvm")

saveRDS(fraction1.peak.ctrl.mvm, file = "Non_synchronized_A549_fraction1.peak.ctrl.mvm")
saveRDS(fraction25.peak.ctrl.mvm, file = "Non_synchronized_A549_fraction25.peak.ctrl.mvm")

saveRDS(fraction1.peak.ctrl.mvm, file = "Non_synchronized_A549_fraction1.peak.ctrl.mvm")
saveRDS(fraction25.peak.ctrl.mvm, file = "Non_synchronized_A549_fraction25.peak.ctrl.mvm")

saveRDS(precipitated.mvm, file = "Non_synchronized_A549_precipitated.mvm")
```

```{r}
# zt
saveRDS(sd.mean.ctrl.zt, file = "Non_synchronized_A549_sd.mean.ctrl.zt ")
saveRDS(sd.mean.rnase.zt , file = "Non_synchronized_A549_sd.mean.rnase.zt")

saveRDS(globalpeak.ctrl.zt, file = "Non_synchronized_A549_globalpeak.ctrl.zt")
saveRDS(globalpeak.value.ctrl.zt, file = "Non_synchronized_A549_globalpeak.value.ctrl.zt")

saveRDS(globalpeak.rnase.zt, file = "Non_synchronized_A549_globalpeak.rnase.zt")
saveRDS(globalpeak.value.rnase.zt, file = "Non_synchronized_A549_globalpeak.value.rnase.zt")

saveRDS(localpeaks.ctrl.zt, file = "Non_synchronized_A549_localpeaks.ctrl.zt")
saveRDS(localpeaks.values.ctrl.zt, file = "Non_synchronized_A549_localpeaks.values.ctrl.zt")

saveRDS(localpeaks.rnase.zt, file = "Non_synchronized_A549_localpeaks.rnase.zt")
saveRDS(localpeaks.values.rnase.zt, file = "Non_synchronized_A549_localpeaks.values.rnase.zt")

saveRDS(fraction1.peak.ctrl.zt, file = "Non_synchronized_A549_fraction1.peak.ctrl.zt")
saveRDS(fraction25.peak.ctrl.zt, file = "Non_synchronized_A549_fraction25.peak.ctrl.zt")

saveRDS(fraction1.peak.ctrl.zt, file = "Non_synchronized_A549_fraction1.peak.ctrl.zt")
saveRDS(fraction25.peak.ctrl.zt, file = "Non_synchronized_A549_fraction25.peak.ctrl.zt")

saveRDS(precipitated.zt, file = "Non_synchronized_A549_precipitated.zt")
```

```{r}
# mms
saveRDS(sd.mean.ctrl.mms, file = "Non_synchronized_A549_sd.mean.ctrl.mms ")
saveRDS(sd.mean.rnase.mms , file = "Non_synchronized_A549_sd.mean.rnase.mms")

saveRDS(globalpeak.ctrl.mms, file = "Non_synchronized_A549_globalpeak.ctrl.mms")
saveRDS(globalpeak.value.ctrl.mms, file = "Non_synchronized_A549_globalpeak.value.ctrl.mms")

saveRDS(globalpeak.rnase.mms, file = "Non_synchronized_A549_globalpeak.rnase.mms")
saveRDS(globalpeak.value.rnase.mms, file = "Non_synchronized_A549_globalpeak.value.rnase.mms")

saveRDS(localpeaks.ctrl.mms, file = "Non_synchronized_A549_localpeaks.ctrl.mms")
saveRDS(localpeaks.values.ctrl.mms, file = "Non_synchronized_A549_localpeaks.values.ctrl.mms")

saveRDS(localpeaks.rnase.mms, file = "Non_synchronized_A549_localpeaks.rnase.mms")
saveRDS(localpeaks.values.rnase.mms, file = "Non_synchronized_A549_localpeaks.values.rnase.mms")

saveRDS(fraction1.peak.ctrl.mms, file = "Non_synchronized_A549_fraction1.peak.ctrl.mms")
saveRDS(fraction25.peak.ctrl.mms, file = "Non_synchronized_A549_fraction25.peak.ctrl.mms")

saveRDS(fraction1.peak.ctrl.mms, file = "Non_synchronized_A549_fraction1.peak.ctrl.mms")
saveRDS(fraction25.peak.ctrl.mms, file = "Non_synchronized_A549_fraction25.peak.ctrl.mms")

saveRDS(precipitated.mms, file = "Non_synchronized_A549_precipitated.mms")
```

## 6. Gaussian fit

Load the relevant data:

```{r}
ctrl.mvm <- readRDS("Non_synchronized_A549_ctrl.mvm")
rnase.mvm <- readRDS("Non_synchronized_A549_rnase.mvm")

ctrl.zt <- readRDS("Non_synchronized_A549_ctrl.zt")
rnase.zt <- readRDS("Non_synchronized_A549_rnase.zt")

ctrl.mms <- readRDS("Non_synchronized_A549_ctrl.mms")
rnase.mms <- readRDS("Non_synchronized_A549_rnase.mms")
```

```{r}
#mvm
saveRDS(sd.mean.rnase.mms , file = "Non_synchronized_A549_sd.mean.rnase.mms")

globalpeak.ctrl.mvm <- readRDS("Non_synchronized_A549_globalpeak.ctrl.mvm")
globalpeak.value.ctrl.mvm <- readRDS("Non_synchronized_A549_globalpeak.value.ctrl.mvm")

globalpeak.rnase.mvm <- readRDS("Non_synchronized_A549_globalpeak.rnase.mvm")
globalpeak.value.rnase.mvm <- readRDS("Non_synchronized_A549_globalpeak.value.rnase.mvm")

localpeaks.ctrl.mvm <- readRDS("Non_synchronized_A549_localpeaks.ctrl.mvm")
localpeaks.values.ctrl.mvm <- readRDS("Non_synchronized_A549_localpeaks.values.ctrl.mvm")

localpeaks.rnase.mvm <- readRDS("Non_synchronized_A549_localpeaks.rnase.mvm")
localpeaks.values.rnase.mvm <- readRDS("Non_synchronized_A549_localpeaks.values.rnase.mvm")

fraction1.peak.ctrl.mvm <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.mvm")
fraction25.peak.ctrl.mvm <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.mvm")

fraction1.peak.ctrl.mvm <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.mvm")
fraction25.peak.ctrl.mvm <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.mvm")

precipitated.mvm <- readRDS("Non_synchronized_A549_precipitated.mvm")
```

```{r}
#zt

globalpeak.ctrl.zt <- readRDS("Non_synchronized_A549_globalpeak.ctrl.zt")
globalpeak.value.ctrl.zt <- readRDS("Non_synchronized_A549_globalpeak.value.ctrl.zt")

globalpeak.rnase.zt <- readRDS("Non_synchronized_A549_globalpeak.rnase.zt")
globalpeak.value.rnase.zt <- readRDS("Non_synchronized_A549_globalpeak.value.rnase.zt")

localpeaks.ctrl.zt <- readRDS("Non_synchronized_A549_localpeaks.ctrl.zt")
localpeaks.values.ctrl.zt <- readRDS("Non_synchronized_A549_localpeaks.values.ctrl.zt")

localpeaks.rnase.zt <- readRDS("Non_synchronized_A549_localpeaks.rnase.zt")
localpeaks.values.rnase.zt <- readRDS("Non_synchronized_A549_localpeaks.values.rnase.zt")

fraction1.peak.ctrl.zt <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.zt")
fraction25.peak.ctrl.zt <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.zt")

fraction1.peak.ctrl.zt <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.zt")
fraction25.peak.ctrl.zt <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.zt")

precipitated.zt <- readRDS("Non_synchronized_A549_precipitated.zt")
```

```{r}
#mms

globalpeak.ctrl.mms <- readRDS("Non_synchronized_A549_globalpeak.ctrl.mms")
globalpeak.value.ctrl.mms <- readRDS("Non_synchronized_A549_globalpeak.value.ctrl.mms")

globalpeak.rnase.mms <- readRDS("Non_synchronized_A549_globalpeak.rnase.mms")
globalpeak.value.rnase.mms <- readRDS("Non_synchronized_A549_globalpeak.value.rnase.mms")

localpeaks.ctrl.mms <- readRDS("Non_synchronized_A549_localpeaks.ctrl.mms")
localpeaks.values.ctrl.mms <- readRDS("Non_synchronized_A549_localpeaks.values.ctrl.mms")

localpeaks.rnase.mms <- readRDS("Non_synchronized_A549_localpeaks.rnase.mms")
localpeaks.values.rnase.mms <- readRDS("Non_synchronized_A549_localpeaks.values.rnase.mms")

fraction1.peak.ctrl.mms <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.mms")
fraction25.peak.ctrl.mms <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.mms")

fraction1.peak.ctrl.mms <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.mms")
fraction25.peak.ctrl.mms <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.mms")

precipitated.mms <- readRDS("Non_synchronized_A549_precipitated.mms")
```

### 6.1 Gaussian fit for Mean Value Method normalized data

Defining relevant parameters for the gauss curve for all proteins of the Control group.

```{r}
# Anzahl der Zeilen im Dataframe
num_rows <- nrow(ctrl.mvm)

# Tabelle zum Speichern der Parameter
parameter_gaussian_ctrl.mvm_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())

# Iteriere über jede Zeile 
for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(ctrl.mvm[i,])

  # Gaussfunktion: f(x) = a * exp(-((x - mu)^2) / (2 * sigma^2))
  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }

  #Finden der besten Parameter für die Gaussfunktion, um die Datenpunkte anzupassen
  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]

    # Berechne die Summe der quadrierten Abweichungen zwischen der Gaussfunktion und den Datenpunkten
    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  # Schätze die Parameter, die die besten Anpassungswerte liefern
  initial_params <- c(1, 3, 1)  # Startwerte für die Parameter a, mu und sigma
  optimized_params <- optim(initial_params, fit_function)$par

  # Speichere die geschätzten Parameter in der Tabelle
  parameter_gaussian_ctrl.mvm_table <- rbind(parameter_gaussian_ctrl.mvm_table, optimized_params)
}
```

Defining relevant parameters for the gauss curve for all proteins of the RNase group.

```{r}
num_rows <- nrow(rnase.mvm)

parameter_gaussian_rnase.mvm_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())

for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(rnase.mvm[i,])

  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }

  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]

    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  initial_params <- c(1, 3, 1) 
  optimized_params <- optim(initial_params, fit_function)$par
  
  parameter_gaussian_rnase.mvm_table <- rbind(parameter_gaussian_rnase.mvm_table, optimized_params)
}
```

### 6.2 Gaussian fit for z-Transformation normalized data

Defining relevant parameters for the gauss curve for all proteins of the Control group.

```{r}
num_rows <- nrow(ctrl.zt)

parameter_gaussian_ctrl.zt_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())
 
for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(ctrl.zt[i,])

  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }

  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]
    
    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  initial_params <- c(1, 3, 1) 
  optimized_params <- optim(initial_params, fit_function)$par

  parameter_gaussian_ctrl.zt_table <- rbind(parameter_gaussian_ctrl.zt_table, optimized_params)
}
```

Defining relevant parameters for the gauss curve for all proteins of the RNase group.

```{r}
num_rows <- nrow(rnase.zt)

parameter_gaussian_rnase.zt_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())

for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(rnase.zt[i,])

  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }

  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]

    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  initial_params <- c(1, 3, 1) 
  optimized_params <- optim(initial_params, fit_function)$par
  
  parameter_gaussian_rnase.zt_table <- rbind(parameter_gaussian_rnase.zt_table, optimized_params)
}
```

### 6.3 Gaussian fit for Min-Max-Scaling normalized data

Defining relevant parameters for the gauss curve for all proteins of the Control group.

```{r}
num_rows <- nrow(ctrl.mms)

parameter_gaussian_ctrl.mms_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())
 
for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(ctrl.mms[i,])

  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }

  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]
    
    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  initial_params <- c(1, 3, 1) 
  optimized_params <- optim(initial_params, fit_function)$par

  parameter_gaussian_ctrl.mms_table <- rbind(parameter_gaussian_ctrl.mms_table, optimized_params)
}
```

Defining relevant parameters for the gauss curve for all proteins of the RNase group.

```{r}
num_rows <- nrow(rnase.mvm)

parameter_gaussian_rnase.mvm_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())

for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(rnase.mvm[i,])

  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }

  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]

    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  initial_params <- c(1, 3, 1) 
  optimized_params <- optim(initial_params, fit_function)$par
  
  parameter_gaussian_rnase.mvm_table <- rbind(parameter_gaussian_rnase.mvm_table, optimized_params)
}
```

###6.4 Plotting of gauss curves

####6.4.1 example of how to plot the curves for all proteins of the Control group

```{r}
num_rows <- nrow(parameter_gaussian_ctrl.zt_table)
plots_gaussian_ctrl.zt <- list()
x <- c(1:25)
for (i in 1:num_rows) {
  a <- parameter_gaussian_ctrl.zt_table[i, 1]
  mu <- parameter_gaussian_ctrl.zt_table[i, 2]
  sigma <- parameter_gaussian_ctrl.zt_table[i, 3]
  row_data_gaussian_ctrl.zt <- parameter_gaussian_ctrl.zt_table[i, ]

  if (sum(!is.na(row_data_gaussian_ctrl.zt)) >= 2) {
    df <- data.frame(x = 1:length(row_data_gaussian_ctrl.zt), y = as.numeric(row_data_gaussian_ctrl.zt))

    # Erstellen eines neuen leeren Plots
    plot_new <- plot(NULL, xlim = c(min(x), max(x)), ylim = c(min(df$y), max(df$y)), 
                     xlab = "Fraction", ylab = "Protein amount", col = "palegreen2", lwd = 2)

    # Zeichnen der Kurve auf dem neuen Plot
    curve(gauss(x, a, mu, sigma), from = min(x), to = max(x), add = TRUE, col = "palegreen2", lwd = 2)

    # Speichern des neuen Plots in der Liste
    plots_gaussian_ctrl.zt[[i]] <- plot_new
    
  } else {
    plots_gaussian_ctrl.zt[[i]] <- NULL
  }

}
```

####6.4.2 example how to plot the Control and RNase curve of one specific protein

```{r}
n=1  #Number of protein you want to see
x <- c(1:25)
a1<- parameter_gaussian_ctrl.zt_table[n, 1 ]
mu1 <- parameter_gaussian_ctrl.zt_table[n, 2]
sigma1 <- parameter_gaussian_ctrl.zt_table[n,3]

a2<- parameter_gaussian_rnase.zt_table[n, 1 ]
mu2 <- parameter_gaussian_rnase.zt_table[n, 2]
sigma2 <- parameter_gaussian_rnase.zt_table[n,3]

plot(x, type = "n", ylim= c(0,50))

curve(gauss(x, a=a1, mu=mu1, sigma=sigma1), from = min(x), to = max(x), add = TRUE, col = "palegreen2", lwd = 2)+
curve(gauss(x, a=a2, mu=mu2, sigma=sigma2), from = min(x), to = max(x), add = TRUE, col = "violet", lwd = 2)
```

Hinweis: Um die Graphen einer anderen Normalisierungsmethode zu sehen, kann zt in mvm oder mms abgeändert werden.

## 7. Parameters to identify RNA-dependent or RNA-binding Proteins 

Load the relevant data:

```{r}
ctrl.mvm <- readRDS("Non_synchronized_A549_ctrl.mvm")
rnase.mvm <- readRDS("Non_synchronized_A549_rnase.mvm")

ctrl.zt <- readRDS("Non_synchronized_A549_ctrl.zt")
rnase.zt <- readRDS("Non_synchronized_A549_rnase.zt")

ctrl.mms <- readRDS("Non_synchronized_A549_ctrl.mms")
rnase.mms <- readRDS("Non_synchronized_A549_rnase.mms")
```

```{r}
#mvm

globalpeak.ctrl.mvm <- readRDS("Non_synchronized_A549_globalpeak.ctrl.mvm")
globalpeak.value.ctrl.mvm <- readRDS("Non_synchronized_A549_globalpeak.value.ctrl.mvm")

globalpeak.rnase.mvm <- readRDS("Non_synchronized_A549_globalpeak.rnase.mvm")
globalpeak.value.rnase.mvm <- readRDS("Non_synchronized_A549_globalpeak.value.rnase.mvm")

localpeaks.ctrl.mvm <- readRDS("Non_synchronized_A549_localpeaks.ctrl.mvm")
localpeaks.values.ctrl.mvm <- readRDS("Non_synchronized_A549_localpeaks.values.ctrl.mvm")

localpeaks.rnase.mvm <- readRDS("Non_synchronized_A549_localpeaks.rnase.mvm")
localpeaks.values.rnase.mvm <- readRDS("Non_synchronized_A549_localpeaks.values.rnase.mvm")

fraction1.peak.ctrl.mvm <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.mvm")
fraction25.peak.ctrl.mvm <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.mvm")

fraction1.peak.ctrl.mvm <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.mvm")
fraction25.peak.ctrl.mvm <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.mvm")

precipitated.mvm <- readRDS("Non_synchronized_A549_precipitated.mvm")
```

```{r}
#zt

globalpeak.ctrl.zt <- readRDS("Non_synchronized_A549_globalpeak.ctrl.zt")
globalpeak.value.ctrl.zt <- readRDS("Non_synchronized_A549_globalpeak.value.ctrl.zt")

globalpeak.rnase.zt <- readRDS("Non_synchronized_A549_globalpeak.rnase.zt")
globalpeak.value.rnase.zt <- readRDS("Non_synchronized_A549_globalpeak.value.rnase.zt")

localpeaks.ctrl.zt <- readRDS("Non_synchronized_A549_localpeaks.ctrl.zt")
localpeaks.values.ctrl.zt <- readRDS("Non_synchronized_A549_localpeaks.values.ctrl.zt")

localpeaks.rnase.zt <- readRDS("Non_synchronized_A549_localpeaks.rnase.zt")
localpeaks.values.rnase.zt <- readRDS("Non_synchronized_A549_localpeaks.values.rnase.zt")

fraction1.peak.ctrl.zt <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.zt")
fraction25.peak.ctrl.zt <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.zt")

fraction1.peak.ctrl.zt <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.zt")
fraction25.peak.ctrl.zt <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.zt")

precipitated.zt <- readRDS("Non_synchronized_A549_precipitated.zt")
```

```{r}
#mms

globalpeak.ctrl.mms <- readRDS("Non_synchronized_A549_globalpeak.ctrl.mms")
globalpeak.value.ctrl.mms <- readRDS("Non_synchronized_A549_globalpeak.value.ctrl.mms")

globalpeak.rnase.mms <- readRDS("Non_synchronized_A549_globalpeak.rnase.mms")
globalpeak.value.rnase.mms <- readRDS("Non_synchronized_A549_globalpeak.value.rnase.mms")

localpeaks.ctrl.mms <- readRDS("Non_synchronized_A549_localpeaks.ctrl.mms")
localpeaks.values.ctrl.mms <- readRDS("Non_synchronized_A549_localpeaks.values.ctrl.mms")

localpeaks.rnase.mms <- readRDS("Non_synchronized_A549_localpeaks.rnase.mms")
localpeaks.values.rnase.mms <- readRDS("Non_synchronized_A549_localpeaks.values.rnase.mms")

fraction1.peak.ctrl.mms <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.mms")
fraction25.peak.ctrl.mms <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.mms")

fraction1.peak.ctrl.mms <- readRDS("Non_synchronized_A549_fraction1.peak.ctrl.mms")
fraction25.peak.ctrl.mms <- readRDS("Non_synchronized_A549_fraction25.peak.ctrl.mms")

precipitated.mms <- readRDS("Non_synchronized_A549_precipitated.mms")
```

### 7.1. Shifts

### 7.1.1. Shifts with Mean Value Method

In this case a shift of more than 2 Fraction is counted as RNA-dependent or RNA-binding.

```{r}
n = 2
shift_mvm_global <- globalpeak.rnase.mvm - globalpeak.ctrl.mvm

shift_mvm_named <- shift_mvm_global
for (i in 1:nrow(rnase.mvm)) {
  if (i %in% precipitated.mvm) {shift_mvm_named[i] <- "precipitated"}
  else if (shift_mvm_global [i] < (-n)){shift_mvm_named [i] <- "right shift"}
  else if (shift_mvm_global [i] > n){shift_mvm_named [i] <- "left shift"}
  else (shift_mvm_named [i] <- "no shift")
}

# View(shift_mvm_named)
```

```{r}
length(shift_mvm_named[shift_mvm_named == "right shift"])
```

```{r}
length(shift_mvm_named[shift_mvm_named == "no shift"])
```

```{r}
length(shift_mvm_named[shift_mvm_named == "left shift"])
```

```{r}
length(shift_mvm_named[shift_mvm_named == "precipitated"])
```
 
To be able to use the data whether a protein is clustered or not, we need to put it in a vector
```{r}
precipitated.mvm

precipitated.mvm.v <- vector(mode = "numeric", length = dim(ctrl.mvm)[1])

for (i in 1:dim(ctrl.mvm)[1]){
  if (i %in% precipitated.mvm){
    precipitated.mvm.v[i] <- 1
  }
  else {
    precipitated.mvm.v[i] <- 0
  }
}

```

### 7.1.2. Shifts with z-Transformation

In this case a shift of more than 2 Fraction is counted as RNA-dependent or RNA-binding.


```{r}
n = 2
shift_zt_global <- globalpeak.rnase.zt - globalpeak.ctrl.zt

shift_zt_named <- shift_zt_global
for (i in 1:nrow(ctrl.zt)) {
  if (i %in% precipitated.zt) {shift_zt_named[i] <- "precipitated"}
  else if (shift_zt_global [i] < (-n)){shift_zt_named [i] <- "right shift"}
  else if (shift_zt_global [i] > n){shift_zt_named [i] <- "left shift"}
  else (shift_zt_named [i] <- "no shift")
}

# View(shift_zt_named)
```

```{r}
length(shift_zt_named[shift_zt_named == "right shift"])
```

```{r}
length(shift_zt_named[shift_zt_named == "no shift"])
```

```{r}
length(shift_zt_named[shift_zt_named == "left shift"])
```

```{r}
length(shift_zt_named[shift_zt_named == "precipitated"])
```


To be able to use the data whether a protein is clustered or not, we need to put it in a vector
```{r}
precipitated.zt

precipitated.zt.v <- vector(mode = "numeric", length = dim(ctrl.zt)[1])

for (i in 1:dim(ctrl.zt)[1]){
  if (i %in% precipitated.zt){
    precipitated.zt.v[i] <- 1
  }
  else {
    precipitated.zt.v[i] <- 0
  }
}
```


### 7.1.3. Shifts with Min-Max Scaling

In this case a shift of more than 2 Fraction is counted as RNA-dependent or RNA-binding.

```{r}
n = 2
shift_mms_global <- globalpeak.rnase.mms - globalpeak.ctrl.mms

shift_mms_named <- shift_mms_global
for (i in 1:nrow(ctrl.mms)) {
  if (i %in% precipitated.mms) {shift_mms_named[i] <- "precipitated"}
  else if (shift_mms_global [i] < (-n)){shift_mms_named [i] <- "right shift"}
  else if (shift_mms_global [i] > n){shift_mms_named [i] <- "left shift"}
  else (shift_mms_named [i] <- "no shift")
}

# View(shift_mms_named)
```

```{r}
length(shift_mms_named[shift_mms_named == "right shift"])
```

```{r}
length(shift_mms_named[shift_mms_named == "no shift"])
```

```{r}
length(shift_mms_named[shift_mms_named == "left shift"])
```

```{r}
length(shift_mms_named[shift_mms_named == "precipitated"])
```

To be able to use the data whether a protein is clustered or not, we need to put it in a vector
```{r}
precipitated.mms

precipitated.mms.v <- vector(mode = "numeric", length = dim(ctrl.mms)[1])

for (i in 1:dim(ctrl.mms)[1]){
  if (i %in% precipitated.mms){
    precipitated.mms.v[i] <- 1
  }
  else {
    precipitated.mms.v[i] <- 0
  }
}

```

### 7.2 Shoulderregions


### 7.2.2 Shoulderregions based on z-Transformed values

Proteins can also be RNA dependent even if they do not have a significant shift. The protein amount can changes significantly without an shift. One indicator could be the appearance of a shoulder regions.

```{r}
shreg.rnase.zt <- rnase.zt
```


First, we identify fraction (regions) of proteins with high protein amount. 
```{r}
largevalues.zt <- apply(shreg.rnase.zt[,2:24], 1, function(x) {
  largevalues_indices <- which(x > 4.5) + 1 # to start again with 2
  peak_mean <- sapply(largevalues_indices, function(i) mean(x[(i-1):(i+1)]))
  largevalues_indices <- largevalues_indices[peak_mean > 4.5]
  unique(c(largevalues_indices - 1 , largevalues_indices, largevalues_indices + 1))
})
```

Then we identify the regions around global and local maxima
```{r}
neighpeaks.rnase.zt <- apply(shreg.rnase.zt, 1,
            function(x) { peak_indices <- which(diff(sign(diff(x))) == -2 & x[-c(1, length(x))] > 3) + 1
              peak_sd <- sapply(peak_indices,function(i) sd(x[(i-1):(i+1)]))
              peak_indices <- peak_indices[peak_sd > mean.sd]
              c(peak_indices - 1, peak_indices, peak_indices + 1)})
```


## 8. Kmeans clustering

### 8.1. MVM

First we will set the variables:
Nur temporär das kmeans funktioniert

```{r}
#shift of local maxima
lshift.mvm <- sample(1:100, length(shift.mms), replace = TRUE)

```

```{r}

gshift <- shift_mvm_global
lshift <- lshift.mvm
precipitated <- precipitated.mvm.v

w.gshift <- 1
w.lshift <- 0
w.precipitated <- 5

peak.ctrl <- globalpeak.ctrl.mvm
peak.rnase <- globalpeak.rnase.mvm

```

#### 8.1.1. Parameters

We want kmeans to consider different parameters for this we put them in a matrix. Here we create and normalize/scale the matrix:

```{r}
parameters.raw <- cbind(gshift, lshift, precipitated)

rownames(parameters.raw) <- rownames(ctrl.mvm)

#hier erst mal MMS, welche wir nehmen können wir noch entscheiden. 
parameters.scaled <- apply(parameters.raw, 2, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
})

```

Not every variable has the same importance. We can weigh the

```{r}

weight <- c(w.gshift, w.lshift, w.precipitated)

for (i in seq_along(weight)){
  parameters.scaled[,i] <- parameters.scaled[,i]*weight[i]
}

parameters <- parameters.scaled

```

#### 8.1.2. kmeans - clustering

Now we cluster the proteins depending on their parameters:

```{r}
# n = Number of clusters
n <- 3
km.mvm <- kmeans(parameters, centers = n, nstart = 100)
```

#### 8.1.3. Plot

Let's plot the peaks against each other:

```{r}
cluster <- km.mvm$cluster

#abhängig davon ob es drei oder vier cluster gibt werden unterschiedliche Vektoren verwendet:

if (n == 3){
  col <- c("springgreen", "violetred1", "cyan")
  vjust <- c(1, -0.5, -0.5)
  labels <- c("no shift", "left shift", "right shift")
}
if (n == 4){
  col <- c("springgreen", "violetred1", "cyan", "orange")
  vjust <- c(-0.5, -0.5, -0.5, -0.5)
  labels <- c("left shift", "right shift", "no shift", "precipitated")
}

library("ggplot2")

#hier wird ein Datframe mit allen für den dotplot relevanten daten erstellt
peaks <- data.frame(peak.ctrl, peak.rnase, cluster)


#für den barplot muss der auch die Ergebnisse des Clusterings als Dataframe dargestellt werden
number.of.clusters <- data.frame(value = cluster)

#das cluster muss als factor dargestellt sein, vector geht nicht
peaks$cluster <- factor(peaks$cluster)

#hier wird der dotplot erstellt der die peaks gegeneinander aufträgt. Die Punkte werden abhängig von ihrer shiftart eingefärbt
dot.plot <- ggplot(peaks, aes(peak.ctrl,peak.rnase)) + 
  geom_point(aes(colour = cluster), shape = 19, alpha = 0.5, size = 2)+
  labs(x = "Fraction of Control Peak", y = "Fraction of RNase Peak", title = "Peak distribution")+
  coord_equal()+
  scale_colour_manual(values = col,labels = labels)+
  theme_light()


# hier wird ein Barplot erstellt der anzeigt, wie oft die shifttypes jeweils vorkommen
bar.plot <- ggplot(number.of.clusters, aes(factor(value)))+
  geom_bar(fill = col
           , width = 0.5)+
  theme_minimal()+
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_blank(), 
        axis.title.y = element_blank(),
        panel.grid = element_blank(),
        panel.border = element_rect(color = "grey", fill = NA),
        panel.background = element_rect(fill = "white", colour = NA))+
  geom_text(stat = 'count', 
            aes(label = after_stat(count)), 
            vjust = vjust, 
            size = 2.5)

#hier werden die beiden plots zusammengefügt. Der barplot wird unten rechts klein angezeigt
dot.plot +
  annotation_custom(grob = ggplotGrob(bar.plot), 
                    xmin = 15, 
                    xmax = 27, 
                    ymin = -1, 
                    ymax = 8)
```

### 8.2. zt

First we will set the variables:

```{r}

gshift <- shift_zt_global
lshift <- lshift.mvm
precipitated <- precipitated.zt.v

w.gshift <- 1
w.lshift <- 0
w.precipitated <- 5

peak.ctrl <- globalpeak.ctrl.zt
peak.rnase <- globalpeak.rnase.zt
```

#### 8.2.1. Parameters

We want kmeans to consider different parameters for this we put them in a matrix. Here we create and normalize/scale the matrix:

```{r}
parameters.raw <- cbind(gshift, lshift, precipitated)

rownames(parameters.raw) <- rownames(ctrl.zt)

#hier erst mal MMS, welche wir nehmen können wir noch entscheiden. 
parameters.scaled <- apply(parameters.raw, 2, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
})

```

Not every variable has the same importance. We can weigh the

```{r}

weight <- c(w.gshift, w.lshift, w.precipitated)

for (i in seq_along(weight)){
  parameters.scaled[,i] <- parameters.scaled[,i]*weight[i]
}

parameters <- parameters.scaled

```

#### 8.2.2. kmeans - clustering

Now we cluster the proteins depending on their parameters:

```{r}
# n = Number of clusters
n <- 3
km.zt <- kmeans(parameters, centers = n, nstart = 100)
```

#### 8.2.3. Plot

Let's plot the peaks against each other:

```{r}
cluster <- km.zt$cluster

#abhängig davon ob es drei oder vier cluster gibt werden unterschiedliche Vektoren verwendet:

if (n == 3){
  col <- c("springgreen", "violetred1", "cyan")
  vjust <- c(1, -0.5, -0.5)
  labels <- c("no shift", "left shift", "right shift")
}
if (n == 4){
  col <- c("springgreen", "violetred1", "cyan", "orange")
  vjust <- c(-0.5, -0.5, -0.5, -0.5)
  labels <- c("left shift", "right shift", "no shift", "precipitated")
}

library("ggplot2")

#hier wird ein Datframe mit allen für den dotplot relevanten daten erstellt
peaks <- data.frame(peak.ctrl, peak.rnase, cluster)


#für den barplot muss der auch die Ergebnisse des Clusterings als Dataframe dargestellt werden
number.of.clusters <- data.frame(value = cluster)

#das cluster muss als factor dargestellt sein, vector geht nicht
peaks$cluster <- factor(peaks$cluster)

#hier wird der dotplot erstellt der die peaks gegeneinander aufträgt. Die Punkte werden abhängig von ihrer shiftart eingefärbt
dot.plot <- ggplot(peaks, aes(peak.ctrl,peak.rnase)) + 
  geom_point(aes(colour = cluster), shape = 19, alpha = 0.5, size = 2)+
  labs(x = "Fraction of Control Peak", y = "Fraction of RNase Peak", title = "Peak distribution")+
  coord_equal()+
  scale_colour_manual(values = col,labels = labels)+
  theme_light()


# hier wird ein Barplot erstellt der anzeigt, wie oft die shifttypes jeweils vorkommen
bar.plot <- ggplot(number.of.clusters, aes(factor(value)))+
  geom_bar(fill = col
           , width = 0.5)+
  theme_minimal()+
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_blank(), 
        axis.title.y = element_blank(),
        panel.grid = element_blank(),
        panel.border = element_rect(color = "grey", fill = NA),
        panel.background = element_rect(fill = "white", colour = NA))+
  geom_text(stat = 'count', 
            aes(label = after_stat(count)), 
            vjust = vjust, 
            size = 2.5)

#hier werden die beiden plots zusammengefügt. Der barplot wird unten rechts klein angezeigt
dot.plot +
  annotation_custom(grob = ggplotGrob(bar.plot), 
                    xmin = 15, 
                    xmax = 27, 
                    ymin = -1, 
                    ymax = 8)
```

### 8.3. MMS

First we will set the variables:

Nur temporär das kmeans funktioniert

```{r}
#shift of local maxima
lshift.mms <- sample(1:100, length(shift.mms), replace = TRUE)

#overlap
overlap.mms <- sample(1:100, length(shift.mms), replace = TRUE)

#precipitated
precipitated.mms <- sample(1:2, length(shift.mms), replace = TRUE)
```

```{r}

gshift <- shift_mms_global
lshift <- lshift.mms
precipitated <- precipitated.mms.v

w.gshift <- 1
w.lshift <- 5
w.precipitated <- 5

peak.ctrl <- peak.mms.ctrl
peak.rnase <- peak.mms.rnase

```

#### 8.3.1. Parameters

We want kmeans to consider different parameters for this we put them in a matrix. Here we create and normalize/scale the matrix:

```{r}
parameters.raw <- cbind(gshift, lshift, precipitated)

rownames(parameters.raw) <- rownames(ctrl.mms)

#hier erst mal MMS, welche wir nehmen können wir noch entscheiden. 
parameters.scaled <- apply(parameters.raw, 2, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
})

```

Not every variable has the same importance. We can weigh them accordingly.

```{r}

weight <- c(w.gshift, w.lshift, w.precipitated)

parameters <- parameters.scaled

for (i in seq_along(weight)){
  parameters[,i] <- parameters.scaled[,i]*weight[i]
}


View(parameters)

```

#### 8.3.2. kmeans - clustering

Now we want to calculate the shift between RNase and Control samples. The value of the RNase-peak will be subtracted from the value of the Control-peak. To know what would be the optimum of clusters we use the elbow method

```{r}


wss <- sapply(1:5, function(x){
  kmeans(parameters, centers = x, nstart = 100)$tot.withinss
})


library("ggplot2")
wss.df <- data.frame(values = wss)
ggplot(wss.df, aes(x = 1:length(wss), y = values))+
  geom_line(col = "mediumvioletred")+
  geom_point(col = "midnightblue")+
  labs(x = "Number of clusters", y = "number of assigned proteins")+
  theme(panel.border = element_rect(color="grey", fill = NA))


```

Now we cluster the proteins depending on their shift:

```{r}
# n = Number of clusters
n <- 3
km.mms <- kmeans(parameters, centers = n, nstart = 100)
```

#### 8.3.3. Plot

Let's plot the peaks against each other:

```{r}

cluster <- km.mms$cluster

#abhängig davon ob es drei oder vier cluster gibt werden unterschiedliche Vektoren verwendet:

if (n == 3){
  col <- c("springgreen", "violetred1", "cyan")
  vjust <- c(1, -0.5, -0.5)
  labels <- c("no shift", "left shift", "right shift")
}
if (n == 4){
  col <- c("springgreen", "violetred1", "cyan", "orange")
  vjust <- c(-0.5, -0.5, -0.5, -0.5)
  labels <- c("left shift", "right shift", "no shift", "precipitated")
}

library("ggplot2")

#hier wird ein Datframe mit allen für den dotplot relevanten daten erstellt
peaks <- data.frame(peak.ctrl, peak.rnase, cluster)


#für den barplot muss der auch die Ergebnisse des Clusterings als Dataframe dargestellt werden
number.of.clusters <- data.frame(value = cluster)

#das cluster muss als factor dargestellt sein, vector geht nicht
peaks$cluster <- factor(peaks$cluster)

#hier wird der dotplot erstellt der die peaks gegeneinander aufträgt. Die Punkte werden abhängig von ihrer shiftart eingefärbt
dot.plot <- ggplot(peaks, aes(peak.ctrl,peak.rnase)) + 
  geom_point(aes(colour = cluster), shape = 19, alpha = 0.5, size = 2)+
  labs(x = "Fraction of Control Peak", y = "Fraction of RNase Peak", title = "Peak distribution")+
  coord_equal()+
  scale_colour_manual(values = col,labels = labels)+
  theme_light()


# hier wird ein Barplot erstellt der anzeigt, wie oft die shifttypes jeweils vorkommen
bar.plot <- ggplot(number.of.clusters, aes(factor(value)))+
  geom_bar(fill = col
           , width = 0.5)+
  theme_minimal()+
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.x = element_blank(), 
        axis.title.y = element_blank(),
        panel.grid = element_blank(),
        panel.border = element_rect(color = "grey", fill = NA),
        panel.background = element_rect(fill = "white", colour = NA))+
  geom_text(stat = 'count', 
            aes(label = after_stat(count)), 
            vjust = vjust, 
            size = 2.5)

#hier werden die beiden plots zusammengefügt. Der barplot wird unten rechts klein angezeigt
dot.plot +
  annotation_custom(grob = ggplotGrob(bar.plot), 
                    xmin = 15, 
                    xmax = 27, 
                    ymin = -1, 
                    ymax = 8)
```


```{r}
as.list(globalpeak.ctrl.zt)
neighborglobalpeak.ctrl.zt <-lapply(globalpeak.ctrl.zt, function(x) {
  if( x > 2 & x < 24){ 
    return(c(x-2, x-1, x, x+1, x+2))
  }
  else {return(numeric(0))
    }
  }
  )
lglobalpeak.rnase.zt <-as.list(globalpeak.rnase.zt)
neighborglobalpeak.rnase.zt <-lapply(lglobalpeak.rnase.zt, function(x) { if( x > 2 &  x < 24){ 
    return(c((x-2), x-1, x, x+1, x+2))
  }
  else {
    return(numeric(0)) # Verwende NA anstelle eines leeren Vektors
    }
  }
)

neighborglobalpeak.ctrl.zt_without_na <- lapply(neighborglobalpeak.ctrl.zt, function(x) ifelse(is.na(x), numeric(0), x))
neighborglobalpeak.rnase.zt_without_na <- lapply(neighborglobalpeak.rnase.zt, function(x) ifelse(is.na(x), numeric(0), x))
overlapneighborglobalpeak.ctrl.zt_without_na <-neighborglobalpeak.ctrl.zt_without_na
overlapneighborglobalpeak.rnase.zt_without_na <- neighborglobalpeak.rnase.zt_without_na
for (i in seq_along(overlapneighborglobalpeak.rnase.zt_without_na)) {
overlapneighborglobalpeak.rnase.zt_without_na[[i]] <- overlapneighborglobalpeak.rnase.zt_without_na[[i]][overlapneighborglobalpeak.rnase.zt_without_na[[i]] %in%  overlapneighborglobalpeak.ctrl.zt_without_na[[i]]]
}
for (i in seq_along(overlapneighborglobalpeak.ctrl.zt_without_na)) {
overlapneighborglobalpeak.ctrl.zt_without_na[[i]] <- overlapneighborglobalpeak.ctrl.zt_without_na[[i]][overlapneighborglobalpeak.ctrl.zt_without_na[[i]] %in%  overlapneighborglobalpeak.rnase.zt_without_na[[i]]]
}
valuesneighborglobalpeak.rnase.zt_without_na <- list()
for (i in seq_along(neighborglobalpeak.rnase.zt_without_na)) {
row_values <- c()
for (j in neighborglobalpeak.rnase.zt_without_na[[i]]) {
value <- rnase.zt[i,j]
row_values <- c(row_values, value)
}
valuesneighborglobalpeak.rnase.zt_without_na[[i]] <- row_values
}
valuesneighborglobalpeak.rnase.zt_without_na
valuesneighborglobalpeak.ctrl.zt_without_na <- list()
for (i in seq_along(neighborglobalpeak.ctrl.zt_without_na)) {
row_values <- c()
for (j in neighborglobalpeak.ctrl.zt_without_na[[i]]) {
value <- rnase.zt[i,j]
row_values <- c(row_values, value)
}
valuesneighborglobalpeak.ctrl.zt_without_na[[i]] <- row_values
}
overlapvaluesneighborglobalpeak.rnase.zt_without_na <- list()
for (i in seq_along(overlapneighborglobalpeak.rnase.zt_without_na)) {
row_values <- c()
for (j in overlapneighborglobalpeak.rnase.zt_without_na[[i]]) {
value <- rnase.zt[i,j]
row_values <- c(row_values, value)
}
overlapvaluesneighborglobalpeak.rnase.zt_without_na[[i]] <- row_values
}
overlapvaluesneighborglobalpeak.rnase.zt_without_na
overlapvaluesneighborglobalpeak.ctrl.zt_without_na <- list()
for (i in seq_along(overlapneighborglobalpeak.ctrl.zt_without_na)) {
row_values <- c()
for (j in overlapneighborglobalpeak.ctrl.zt_without_na[[i]]) {
value <- rnase.zt[i,j]
row_values <- c(row_values, value)
}
overlapvaluesneighborglobalpeak.ctrl.zt_without_na[[i]] <- row_values
}
sumoverlapvaluesneighborglobalpeak.ctrl.zt_without_na <-lapply(overlapvaluesneighborglobalpeak.ctrl.zt_without_na, function(x) sum(x))
sumoverlapvaluesneighborglobalpeak.rnase.zt_without_na <-lapply(overlapvaluesneighborglobalpeak.rnase.zt_without_na, function(x) sum(x))
sumvaluesneighborglobalpeak.ctrl.zt_without_na <-lapply(valuesneighborglobalpeak.ctrl.zt_without_na, function(x) sum(x))
sumvaluesneighborglobalpeak.rnase.zt_without_na <-lapply(valuesneighborglobalpeak.rnase.zt_without_na, function(x) sum(x))
```

```{r}
neighborglobalpeak.ctrl.zt_without_na <- lapply(neighborglobalpeak.ctrl.zt, function(x) ifelse(is.na(x), numeric(0), x))
neighborglobalpeak.rnase.zt_without_na <- lapply(neighborglobalpeak.rnase.zt, function(x) ifelse(is.na(x), numeric(0), x))
overlapneighborglobalpeak.ctrl.zt_without_na <-neighborglobalpeak.ctrl.zt_without_na
overlapneighborglobalpeak.rnase.zt_without_na <- neighborglobalpeak.rnase.zt_without_na
for (i in seq_along(overlapneighborglobalpeak.rnase.zt_without_na)) {
overlapneighborglobalpeak.rnase.zt_without_na[[i]] <- overlapneighborglobalpeak.rnase.zt_without_na[[i]][overlapneighborglobalpeak.rnase.zt_without_na[[i]] %in%  overlapneighborglobalpeak.ctrl.zt_without_na[[i]]]
}
for (i in seq_along(overlapneighborglobalpeak.ctrl.zt_without_na)) {
overlapneighborglobalpeak.ctrl.zt_without_na[[i]] <- overlapneighborglobalpeak.ctrl.zt_without_na[[i]][overlapneighborglobalpeak.ctrl.zt_without_na[[i]] %in%  overlapneighborglobalpeak.rnase.zt_without_na[[i]]]
}
valuesneighborglobalpeak.rnase.zt_without_na <- list()
for (i in seq_along(neighborglobalpeak.rnase.zt_without_na)) {
row_values <- c()
for (j in neighborglobalpeak.rnase.zt_without_na[[i]]) {
value <- rnase.zt[i,j]
row_values <- c(row_values, value)
}
valuesneighborglobalpeak.rnase.zt_without_na[[i]] <- row_values
}
valuesneighborglobalpeak.rnase.zt_without_na
valuesneighborglobalpeak.ctrl.zt_without_na <- list()
for (i in seq_along(neighborglobalpeak.ctrl.zt_without_na)) {
row_values <- c()
for (j in neighborglobalpeak.ctrl.zt_without_na[[i]]) {
value <- rnase.zt[i,j]
row_values <- c(row_values, value)
}
valuesneighborglobalpeak.ctrl.zt_without_na[[i]] <- row_values
}
overlapvaluesneighborglobalpeak.rnase.zt_without_na <- list()
for (i in seq_along(overlapneighborglobalpeak.rnase.zt_without_na)) {
row_values <- c()
for (j in overlapneighborglobalpeak.rnase.zt_without_na[[i]]) {
value <- rnase.zt[i,j]
row_values <- c(row_values, value)
}
overlapvaluesneighborglobalpeak.rnase.zt_without_na[[i]] <- row_values
}
overlapvaluesneighborglobalpeak.rnase.zt_without_na
overlapvaluesneighborglobalpeak.ctrl.zt_without_na <- list()
for (i in seq_along(overlapneighborglobalpeak.ctrl.zt_without_na)) {
row_values <- c()
for (j in overlapneighborglobalpeak.ctrl.zt_without_na[[i]]) {
value <- rnase.zt[i,j]
row_values <- c(row_values, value)
}
overlapvaluesneighborglobalpeak.ctrl.zt_without_na[[i]] <- row_values
}
sumoverlapvaluesneighborglobalpeak.ctrl.zt_without_na <-lapply(overlapvaluesneighborglobalpeak.ctrl.zt_without_na, function(x) sum(x))
sumoverlapvaluesneighborglobalpeak.rnase.zt_without_na <-lapply(overlapvaluesneighborglobalpeak.rnase.zt_without_na, function(x) sum(x))
sumvaluesneighborglobalpeak.ctrl.zt_without_na <-lapply(valuesneighborglobalpeak.ctrl.zt_without_na, function(x) sum(x))
sumvaluesneighborglobalpeak.rnase.zt_without_na <-lapply(valuesneighborglobalpeak.rnase.zt_without_na, function(x) sum(x))
```

