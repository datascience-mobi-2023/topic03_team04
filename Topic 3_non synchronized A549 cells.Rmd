```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) 
```

# Proteome-wide Screen for RNA-dependent Proteins: *non-synchronized A549 cells*

Zum PDF exportieren

```{r}
tinytex::install_tinytex()
```

Loading the data:

```{r}
MS_Table <- read.delim('https://www.dropbox.com/s/vm3lxljjm9chau8/RDeeP_A549_NS.csv?dl=1', header=TRUE, row.names=1, sep = ";")
```

## 0. Data description

```{r}
dim(MS_Table)
head(rownames(MS_Table))
head(colnames(MS_Table))
```

## 1. Preparing data for analysis

### 1.1 Check for missing values

```{r}
sum(apply(MS_Table, 1, anyNA)) == 0
sum(is.na(MS_Table)) == 0
```

### 1.2 Check data format

```{r}
sum(apply(MS_Table, 1, is.numeric)) == nrow(MS_Table)
```

### 1.3 Deleting rows with only zeros

```{r}
min(MS_Table)
sum(apply(MS_Table,1,sum)==0)
```

-\> da die Summe der Zeileneinträge keines Proteins 0 entspricht, wurde ein Dataframe aus False erstellt. Einträge ausschließlich False, werden durch die sum Funktion als 0 aufaddiert.

### 1.4 Rearranging of Data

#### 1.4.1 Reordering columns

```{r}
MS_Table_reordered <- MS_Table[, c(
  paste0("Fraction", 1:25, "_Ctrl_Rep1"),
  paste0("Fraction", 1:25, "_Ctrl_Rep2"),
  paste0("Fraction", 1:25, "_Ctrl_Rep3"),
  paste0("Fraction", 1:25, "_RNase_Rep1"),
  paste0("Fraction", 1:25, "_RNase_Rep2"),
  paste0("Fraction", 1:25, "_RNase_Rep3")
)]
# View(MS_Table_reordered)
sum(apply(MS_Table_reordered, 2, is.numeric)) == ncol(MS_Table)
```

#### 1.4.2 Separate Ctrl and RNase

```{r}
MS_Table_Ctrl <-MS_Table_reordered[,1:75]
#View(MS_Table_Ctrl)
MS_Table_RNase <-MS_Table_reordered[,76:150]
#View(MS_Table_RNase)
```

### 1.5. Reproducibility

Here we test whether the replicates are similar to each other. This would mean, that the experiment is reproducible, thus the data is reliable. Proteins that do not satisfy this condition will be removed from the dataset and will not be analysed.

#### Fabio's Idea:

An idea to check the reproducibility -\> das hinzufügen der Funktion as.numeric hat das Problem gelöst

```{r}
num_rows <- nrow(MS_Table_Ctrl_rep1)

# create vector 
correlations <- numeric(num_rows) 


for (i in 1:num_rows) {
  # select row i from MS_Table_Ctrl_rep1 and MS_Table_Ctrl_rep2 
  row_rep1 <- as.numeric(MS_Table_Ctrl_rep1[i, ]) 
  # Der Fehler war, dass die Rows nicht als Vector, sondern als Dataframe eingelesen wurden -> Sobald der Type richtig ist, kann er auch die Correlation ausrechnen. 
  # Als weiterer Hinweis jedoch: Die Operation könnte etwas länger dauern, wenn ihrs für alle dfs macht. 
  row_rep2 <- as.numeric(MS_Table_Ctrl_rep2[i, ])
  
  
  correlation <- cor(row_rep1, row_rep2, method = "pearson")
  
  
  correlations[i] <- correlation
}

# show result 
correlations

#Achtung: funktioniert nicht, aber ich weiß nicht warum Fehlermeldung auftritt

```

## 2. Scale and Reduce Dataset

For the normalization each replicate has to be separated, therefore we design 6 separate dataframes.

```{r}
ctrl.rep1 <-MS_Table_reordered[,1:25]
ctrl.rep2 <-MS_Table_reordered[,26:50]
ctrl.rep3 <-MS_Table_reordered[,51:75]
rnase.rep1 <-MS_Table_reordered[,76:100]
rnase.rep2 <-MS_Table_reordered[,101:125]
rnase.rep3 <-MS_Table_reordered[,126:150]
```

### 2.1a Normalization (mean value method)

On them we apply separately the mean value method.

```{r}
#rowMeans(MS_Table_Ctrl_rep1)
#apply(MS_Table_Ctrl_rep1,1,sd)
MS_Table_Ctrl_rep1_normalized <- apply(t(MS_Table_Ctrl_rep1),1, function(x)(x - mean(x)) / sd(x))
View(MS_Table_Ctrl_rep1_normalized)
# Der oben stehende code führt nicht die mean value methode durch. Daher siehe unten.  
```

We perform the mean-value-method (mvm) on each replicate, both control and RNase:

```{r}
# Control Replicate 1 MVM
ctrl.rep1.mvm.norm <- t(apply(ctrl.rep1, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# View(ctrl.rep1.mvm.norm)

# Control Replicate 2 MVM
ctrl.rep2.mvm.norm <- t(apply(ctrl.rep2, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# Control Replicate 3 MVM
ctrl.rep3.mvm.norm <- t(apply(ctrl.rep3, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# RNase Replicate 1 MVM
rnase.rep1.mvm.norm <- t(apply(rnase.rep1, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# RNase Replicate 2 MVM
rnase.rep2.mvm.norm <- t(apply(rnase.rep2, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# RNase Replicate 3 MVM
rnase.rep3.mvm.norm <- t(apply(rnase.rep3, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

```

### 2.1b Normalization (Min-Max-Scaling)

We perform min-max-scaling (mms) on each replicate, both control and RNase:

```{r}

# Control Replicate 1 MMS
ctrl.rep1.mms.norm <- t(apply(ctrl.rep1, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# Control Replicate 2 MMS
ctrl.rep2.mms.norm <- t(apply(ctrl.rep2, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# Control Replicate 3 MMS
ctrl.rep3.mms.norm <- t(apply(ctrl.rep3, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# RNase Replicate 1 MMS
rnase.rep1.mms.norm <- t(apply(rnase.rep1, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# RNase Replicate 2 MMS
rnase.rep2.mms.norm <- t(apply(rnase.rep2, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# RNase Replicate 2 MMS
rnase.rep3.mms.norm <- t(apply(rnase.rep3, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))
```

To prove that the algorithm works we use is on a test matrix: (byrow = TRUE, dass die Zahen Zeilenweise die Matrix füllen, nicht spaltenweise)

```{r}
test_matrix <- matrix(c(1,45,3,8,27,4,79,30,0,100,99,50,0,76,1,4,6,3,8,7,3), byrow = TRUE, nrow = 3)

test_normalized <- t(apply(test_matrix, 1, function(x){
  normalized <- (x-min(x))/(max(x)-min(x))
}))

#test_matrix
#test_normalized
```

Now we merge the three replicates:

```{r}
ctrl.mms.merged <- ((ctrl.rep1.mms.norm + ctrl.rep2.mms.norm + ctrl.rep3.mms.norm)/3)

rnase.mms.merged <- ((rnase.rep1.mms.norm + rnase.rep2.mms.norm + rnase.rep3.mms.norm)/3)
```

Those have to be scaled again:

```{r}
ctrl.mms <- t(apply(ctrl.mms.merged, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

rnase.mms <- t(apply(rnase.mms.merged, 1, function(x){
  normalized <- (x-min(x))/(max(x)-min(x))
}))
```

Now we can plot graphs that show the result of the merge and second scaling. This is only an example (control sample of the first protein), the plotting of all proteins will be done later on:

```{r}
##plots of the scaled replicates

#plot(rnase.rep1.mms.norm[1,], xlab="fraction", ylab="protein amount", col="green", pch=20)
#plot(rnase.rep2.mms.norm[1,], xlab="fraction", ylab="protein amount", col="green", pch=20)
#plot(rnase.rep3.mms.norm[1,], xlab="fraction", ylab="protein amount", col="green", pch=20)

##plot of the merged ctrl

#plot(rnase.mms.merged[1,], xlab="fraction", ylab="protein amount", col="red", pch=20)

##plot of the merged and scaled ctrl
#plot(rnase.mms[1,], xlab="fraction", ylab="protein amount", col="blue", pch=20)
```
