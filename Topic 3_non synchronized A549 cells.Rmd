```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) 
```

# Proteome-wide Screen for RNA-dependent Proteins: *non-synchronized A549 cells*

Loading the data:

```{r}
MS_Table <- read.csv('https://www.dropbox.com/s/r417vauyr7cku8s/A549dataset.csv?dl=1', header=TRUE, row.names=1, sep = ",")
```

## 1. Preparing data for analysis

### 1.1. Check for missing values

Here we check whether there are any missing values in our data. There are none.

```{r}
sum(apply(MS_Table, 1, anyNA)) == 0
sum(is.na(MS_Table)) == 0
```

### 1.2. Check data format

Here we check whether all data is numeric. This is the case is.

```{r}
sum(apply(MS_Table, 1, is.numeric)) == nrow(MS_Table)
```

### 1.3. Deleting rows with only zeros

Here we check whether there are rows that only have zeros. This is not the case. 
```{r}
sum(apply(MS_Table,1,sum)==0)
```

### 1.4. Rearranging of Data

#### 1.4.1. Reordering columns

We rearrange our data frame, so that we can work with it more easily. 

```{r}
MS_Table_reordered <- MS_Table[, c(
  paste0("Fraction", 1:25, "_Ctrl_Rep1"),
  paste0("Fraction", 1:25, "_Ctrl_Rep2"),
  paste0("Fraction", 1:25, "_Ctrl_Rep3"),
  paste0("Fraction", 1:25, "_RNase_Rep1"),
  paste0("Fraction", 1:25, "_RNase_Rep2"),
  paste0("Fraction", 1:25, "_RNase_Rep3")
)]
# View(MS_Table_reordered)
```

#### 1.4.2. Separate Ctrl and RNase

To work with the RNase and Control data separately, we create two new data frames. 

```{r}
MS_Table_Ctrl <-MS_Table_reordered[,1:75]
#View(MS_Table_Ctrl)
MS_Table_RNase <-MS_Table_reordered[,76:150]
# View(MS_Table_RNase)
```

## 2. Reproducibility

Here we test whether the replicates are similar to each other. This would mean, that the experiment is reproducible, thus the data is reliable. Proteins that do not satisfy this condition will be removed from the dataset and will not be analysed.

#### 2.1 Pearson Correlation

To facilitate the calculation of the correlation between each replicate, we design 6 separate data frames, one for each replicate

```{r}
ctrl.rep1.reprod <- MS_Table_reordered[,1:25]
ctrl.rep2.reprod <- MS_Table_reordered[,26:50]
ctrl.rep3.reprod <- MS_Table_reordered[,51:75]
rnase.rep1.reprod <- MS_Table_reordered[,76:100]
rnase.rep2.reprod <- MS_Table_reordered[,101:125]
rnase.rep3.reprod <- MS_Table_reordered[,126:150]
```

Here we calculate the correlation between the replicates and put them together in one data frame (ctrl.cor and rnase.cor) 

```{r, echo=FALSE, warning = FALSE}
ctrl.cor <- 
  cbind(ctrl.cor.rep1.rep2 <- 
          sapply(seq.int(dim(ctrl.rep1.reprod)[1]), 
                 function(x) cor(as.numeric(ctrl.rep1.reprod[x,]), as.numeric(ctrl.rep2.reprod[x,]))),
        ctrl.cor.rep2.rep3 <- 
          sapply(seq.int(dim(ctrl.rep1.reprod)[1]), 
                 function(x) cor(as.numeric(ctrl.rep2.reprod[x,]), as.numeric(ctrl.rep3.reprod[x,]))), 
        ctrl.cor.rep1.rep3 <- 
          sapply(seq.int(dim(ctrl.rep1.reprod)[1]), 
                 function(x) cor(as.numeric(ctrl.rep1.reprod[x,]), as.numeric(ctrl.rep3.reprod[x,]))))

rnase.cor <- 
  cbind(rnase.cor.rep1.rep2 <- 
         sapply(seq.int(dim(rnase.rep1.reprod)[1]), 
                function(x) cor(as.numeric(rnase.rep1.reprod[x,]), as.numeric(rnase.rep2.reprod[x,]))),
        rnase.cor.rep2.rep3 <- 
          sapply(seq.int(dim(rnase.rep1.reprod)[1]), 
                 function(x) cor(as.numeric(rnase.rep2.reprod[x,]), as.numeric(rnase.rep3.reprod[x,]))), 
        rnase.cor.rep1.rep3 <- 
          sapply(seq.int(dim(rnase.rep1.reprod)[1]), 
                 function(x) cor(as.numeric(rnase.rep1.reprod[x,]), as.numeric(rnase.rep3.reprod[x,]))))

ctrl.rnase.cor <- cbind(ctrl.cor,rnase.cor)
```


Now we eliminate proteins which have NA-correlations (this happens when they contain replicates with only 0s). We then create new separate data frames for each replicate.

```{r}
total.na <- which(rowSums(is.na(ctrl.rnase.cor)) > 0)
MS.Table.naremoved <- MS_Table_reordered[-total.na,]

ctrl.rep1.naremoved <- MS.Table.naremoved[,1:25]
ctrl.rep2.naremoved <- MS.Table.naremoved[,26:50]
ctrl.rep3.naremoved <- MS.Table.naremoved[,51:75]
rnase.rep1.naremoved <- MS.Table.naremoved[,76:100]
rnase.rep2.naremoved <- MS.Table.naremoved[,101:125]
rnase.rep3.naremoved <- MS.Table.naremoved[,126:150]
```

Now we calculate the correlation of the replicates. This time the proteins that contain replicates with only 0 are already eliminated, so there shouldn't be any NAs anymore.

```{r}
ctrl.cor.naremoved <- 
  cbind(ctrl.cor.rep1.rep2.naremoved <- 
          sapply(seq.int(dim(ctrl.rep1.naremoved)[1]), 
                 function(x) cor(as.numeric(ctrl.rep1.naremoved[x,]), as.numeric(ctrl.rep2.naremoved[x,]))),
        ctrl.cor.rep2.rep3.naremoved <- 
          sapply(seq.int(dim(ctrl.rep1.naremoved)[1]), 
                 function(x) cor(as.numeric(ctrl.rep2.naremoved[x,]), as.numeric(ctrl.rep3.naremoved[x,]))),
        ctrl.cor.rep1.rep3.naremoved <- 
          sapply(seq.int(dim(ctrl.rep1.naremoved)[1]), 
                 function(x) cor(as.numeric(ctrl.rep1.naremoved[x,]), as.numeric(ctrl.rep3.naremoved[x,]))))

rnase.cor.naremoved <- 
  cbind(rnase.cor.rep1.rep2.naremoved <- 
         sapply(seq.int(dim(rnase.rep1.naremoved)[1]), function(x) cor(as.numeric(rnase.rep1.naremoved[x,]), as.numeric(rnase.rep2.naremoved[x,]))),
        rnase.cor.rep2.rep3.naremoved <- 
          sapply(seq.int(dim(rnase.rep1.naremoved)[1]), function(x) cor(as.numeric(rnase.rep2.naremoved[x,]), as.numeric(rnase.rep3.naremoved[x,]))), 
        rnase.cor.rep1.rep3.naremoved <- 
          sapply(seq.int(dim(rnase.rep1.naremoved)[1]), function(x) cor(as.numeric(rnase.rep1.naremoved[x,]), as.numeric(rnase.rep3.naremoved[x,]))))
```


The following plot shows us the general distribution of correlation.

In total we look at 3\*(3680-83) = 10 791 correlations. This has to be taken into account, when looking at the graphs. It is import to figure out if the 3 correlations are for one protein or for 3 different ones.

```{r}
library(ggplot2)
ctrl.cor.data.frame.naremoved <- data.frame(c(ctrl.cor.naremoved[,1],ctrl.cor.naremoved[,2],ctrl.cor.naremoved[,3]))
colnames(ctrl.cor.data.frame.naremoved) <- "correlation"
ggplot(ctrl.cor.data.frame.naremoved, aes(x=correlation)) + geom_histogram()
```

We do the same for the RNase group:

```{r}
library(ggplot2)
rnase.cor.data.frame.naremoved <- data.frame(c(rnase.cor.naremoved[,1],rnase.cor.naremoved[,2],rnase.cor.naremoved[,3]))
colnames(rnase.cor.data.frame.naremoved) = "correlation"
ggplot(rnase.cor.data.frame.naremoved, aes(x=correlation)) + geom_histogram()
```

Now we select the proteins which have correlations beneath 0.9. Those are not reproducible, thus the data is not safe enough to be used further.

First we determine the proteins that only have correlations under 0.9.

```{r}
non.reproducible.ctrl <- which(rowSums(ctrl.cor.naremoved<0.9)>2)
non.reproducible.rnase <- which(rowSums(rnase.cor.naremoved<0.9)>2)
non.reproducible <- unique(c(non.reproducible.ctrl, non.reproducible.rnase))
```

Now we eliminate the proteins that only have correlations under 0.9.

```{r}
ctrl.rep <- MS.Table.naremoved[-non.reproducible,1:75]
rnase.rep <- MS.Table.naremoved[-non.reproducible,76:150]

ctrl.cor.removed <- ctrl.cor.naremoved [-non.reproducible,]
rnase.cor.removed <- rnase.cor.naremoved [-non.reproducible,]
```

Other proteins are a bit trickier. Some proteins have two replicates similar to each other (correlation < 0.9) and a third one that completely differs. These Proteins have one very high and two smaller correlations. The different replicate is often the third one. To avoid loosing too many proteins, but still have safe data, we ignore the bad replicates. For this we first set them to NA. After the normalization-set we can ignore them when uniting the replicates.

```{r}
for (x in 1:dim(ctrl.rep)[1]){
  if (ctrl.cor.removed[x, 1] < 0.9) {
    if (ctrl.cor.removed[x, 3] < 0.9){
      ctrl.rep[x, 1:25] <- NA 
    }
    if (ctrl.cor.removed[x, 2] < 0.9){
      ctrl.rep[x, 26:50] <- NA
    }}
  
  if (ctrl.cor.removed[x, 3] < 0.9) {
    if (ctrl.cor.removed[x, 2] < 0.9){
      ctrl.rep[x, 51:75] <- NA
    }
  }
     }

for (x in 1:dim(rnase.rep)[1]){
  if (rnase.cor.removed[x, 1] < 0.9) {
    if (rnase.cor.removed[x, 3] < 0.9){
      rnase.rep[x, 1:25] <- NA 
    }
    if (rnase.cor.removed[x, 2] < 0.9){
      rnase.rep[x, 26:50] <- NA
    }}
  
  if (rnase.cor.removed[x, 3] < 0.9) {
    if (rnase.cor.removed[x, 2] < 0.9){
      rnase.rep[x, 51:75] <- NA
    }
  }
}
```

We now have 3074 Proteins left. 
We now have clean data, with proteins that have reproducible data we can use for further analysis.

## 3. Scaled and Reduced Dataset

We use three different normalization methods: Mean-Value-Method, z-Transformation and Min-Max-scaling.  At the end of the project we will be able to compare them and determine which one is the best. 

For the normalization each replicate has to be separated, therefore we design 6 separate data frames. 

```{r}
ctrl.rep1 <- ctrl.rep[,1:25]
ctrl.rep2 <- ctrl.rep[,26:50]
ctrl.rep3 <- ctrl.rep[,51:75]
rnase.rep1 <- rnase.rep[,1:25]
rnase.rep2 <- rnase.rep[,26:50]
rnase.rep3 <- rnase.rep[,51:75]
```

### 3.1. Mean Value Method

#### 3.1.1. Normalization

We perform the mean-value-method (MVM) on each replicate, both Control and RNase:

```{r}
# Control Replicate 1 MVM
ctrl.rep1.mvm.norm <- t(apply(ctrl.rep1, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# Control Replicate 2 MVM
ctrl.rep2.mvm.norm <- t(apply(ctrl.rep2, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# Control Replicate 3 MVM
ctrl.rep3.mvm.norm <- t(apply(ctrl.rep3, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# RNase Replicate 1 MVM
rnase.rep1.mvm.norm <- t(apply(rnase.rep1, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# RNase Replicate 2 MVM
rnase.rep2.mvm.norm <- t(apply(rnase.rep2, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))

# RNase Replicate 3 MVM
rnase.rep3.mvm.norm <- t(apply(rnase.rep3, 1, function(x) {
  normalized <- x - mean(x)
  normalized[normalized < 0] <- 0
  scaled <- normalized * (100 / sum(normalized))
  return(scaled)
}))
```

#### 3.1.2. Reduction

To unite the replicates and thus reduce the data, we take the mean values of the replicates. Here we must consider the NA-values of non-reproducible replicates.

```{r}
r1c <- ctrl.rep1.mvm.norm
r2c <- ctrl.rep2.mvm.norm
r3c <- ctrl.rep3.mvm.norm

r1c0 <- ctrl.rep1.mvm.norm
r2c0 <- ctrl.rep2.mvm.norm
r3c0 <- ctrl.rep3.mvm.norm

r1c0[is.na(r1c)] <- 0
r2c0[is.na(r2c)] <- 0
r3c0[is.na(r3c)] <- 0

ctrl.mvm.reduced <-  (r1c0 + r2c0 + r3c0)/(3-((sum(is.na(r1c[x,]) + is.na(r2c[x,]) + is.na(r3c[x,])))/25))

```

```{r}
r1r <- rnase.rep1.mvm.norm
r2r <- rnase.rep2.mvm.norm
r3r <- rnase.rep3.mvm.norm

r1r0 <- rnase.rep1.mvm.norm
r2r0 <- rnase.rep2.mvm.norm
r3r0 <- rnase.rep3.mvm.norm

r1r0[is.na(r1r)] <- 0
r2r0[is.na(r2r)] <- 0
r3r0[is.na(r3r)] <- 0

rnase.mvm.reduced <-  (r1r0 + r2r0 + r3r0)/(3 - ((sum(is.na(r1r[x,]) + is.na(r2r[x,]) + is.na(r3r[x,])))/25))

```

#### 3.1.3. Scaling

-\> scaling back to 100 is necessary

Because scaling back to 100 is necessary, we do it for both, Control and RNase:

```{r}
ctrl.mvm.scaled = 
  sweep(ctrl.mvm.reduced,1,100/rowSums(ctrl.mvm.reduced),'*')

rnase.mvm.scaled = 
  sweep(rnase.mvm.reduced,1,100/rowSums(rnase.mvm.reduced),'*')
```

To test whether we have "lost" our scaling during the merge, and find out whether the scaling back to 100 performed in the previous chunk is necessary, we scale the control to 100 and compare it with the original control.

```{r}
# Check if the two data frames are identical
is_identical <- identical(ctrl.mvm.reduced, ctrl.mvm.scaled)

# Print the result
if (is_identical) {
  print("The data frames are identical.")
 } else {
  print("The data frames are not identical.")
 }
```

Now we have normalized our data using the mean-value-method, and scaled it to 100. The two variables that will be used later on either contain the normalized (MVM) and scaled data of the control: **ctrl.mvm** or the normalized (MVM) and scaled data of the rnase: **rnase.mvm**

```{r}
new.colnames.ctrl <- c("Fraction_1_Ctrl","Fraction_2_Ctrl","Fraction_3_Ctrl","Fraction_4_Ctrl","Fraction_5_Ctrl","Fraction_6_Ctrl","Fraction_7_Ctrl","Fraction_8_Ctrl","Fraction_9_Ctrl","Fraction_10_Ctrl","Fraction_11_Ctrl","Fraction_12_Ctrl","Fraction_13_Ctrl","Fraction_14_Ctrl","Fraction_15_Ctrl","Fraction_16_Ctrl","Fraction_17_Ctrl","Fraction_18_Ctrl","Fraction_19_Ctrl","Fraction_20_Ctrl","Fraction_21_Ctrl","Fraction_22_Ctrl","Fraction_23_Ctrl","Fraction_24_Ctrl","Fraction_25_Ctrl")

new.colnames.rnase <- c("Fraction_1_RNase","Fraction_2_RNase","Fraction_3_RNase","Fraction_4_RNase","Fraction_5_RNase","Fraction_6_RNase","Fraction_7_RNase","Fraction_8_RNase","Fraction_9_RNase","Fraction_10_RNase","Fraction_11_RNase","Fraction_12_RNase","Fraction_13_RNase","Fraction_14_RNase","Fraction_15_RNase","Fraction_16_RNase","Fraction_17_RNase","Fraction_18_RNase","Fraction_19_RNase","Fraction_20_RNase","Fraction_21_RNase","Fraction_22_RNase","Fraction_23_RNase","Fraction_24_RNase","Fraction_25_RNase")

ctrl.mvm <- ctrl.mvm.scaled
colnames(ctrl.mvm) <- new.colnames.ctrl

rnase.mvm <- rnase.mvm.scaled
colnames(rnase.mvm) <- new.colnames.rnase
```

### 3.2. z - Transformation

#### 3.2.1. Normalization

The z-Transformation does not work with df that have NA-values. This means we cannot use the ctrl.clean and rnase.clean df. We have to use the old ctrl.rep or the MS.Table.naremoved[-non.reproducible,1:75] dfs. On these we first perform z-Transformation and then we use the same algorithms as before to reduce the data set in regards to reproducibility. 

```{r}
ctrl.rep.zt <- MS.Table.naremoved[-non.reproducible,1:75]
rnase.rep.zt <- MS.Table.naremoved[-non.reproducible,76:150]

ctrl.rep1z <- ctrl.rep.zt[,1:25]
ctrl.rep2z <- ctrl.rep.zt[,26:50]
ctrl.rep3z <- ctrl.rep.zt[,51:75]
ctrl.repz <- cbind(ctrl.rep1z,ctrl.rep2z,ctrl.rep3z)


rnase.rep1z <- rnase.rep.zt[,1:25]
rnase.rep2z <- rnase.rep.zt[,26:50]
rnase.rep3z <- rnase.rep.zt[,51:75]
rnase.repz <- cbind(rnase.rep1z,rnase.rep2z,rnase.rep3z)
```

First the normalization for the Ctrl:

Since the protein amount in each replicate is different, it is better to calculate the mean for each replicate separately. However the sd-value does not have to be adapted. Because the replicates have the same variance (same procedure for every replicate in the wet lab), we don't have to calculate the standard devidation for the replicates in each fraction extra. We can calculate the sd-value for one row /sd.

sd-values and mean values of Ctrl:

```{r}
sd.ctrl <- apply(ctrl.repz, 1, sd)

mean.ctrl.rep1 <- apply(ctrl.rep1z, 1, mean)
mean.ctrl.rep2 <- apply(ctrl.rep2z, 1, mean)
mean.ctrl.rep3 <- apply(ctrl.rep3z, 1, mean)
```

Normalization of Ctrl:

```{r}
ctrl.rep1.meanvalue <- sweep(ctrl.rep1z,1,mean.ctrl.rep1,'-')
ctrl.rep1.zt.norm <- sweep(ctrl.rep1.meanvalue,1,sd.ctrl,'/')

ctrl.rep2.meanvalue <- sweep(ctrl.rep2z,1,mean.ctrl.rep2,'-')
ctrl.rep2.zt.norm <- sweep(ctrl.rep2.meanvalue,1,sd.ctrl,'/')

ctrl.rep3.meanvalue <- sweep(ctrl.rep3z,1,mean.ctrl.rep3,'-')
ctrl.rep3.zt.norm <- sweep(ctrl.rep3.meanvalue,1,sd.ctrl,'/')

#calculate again the min value for each protein
min.ctrl.rep1.zt.norm <- apply(ctrl.rep1.zt.norm, 1, min)
min.ctrl.rep2.zt.norm <- apply(ctrl.rep2.zt.norm, 1, min)
min.ctrl.rep3.zt.norm <- apply(ctrl.rep3.zt.norm, 1, min)

#substract the min value from each position to discard the 0
ctrl.rep1.zt.norm.pos <- sweep(ctrl.rep1.zt.norm,1,min.ctrl.rep1.zt.norm,FUN = '-')
ctrl.rep2.zt.norm.pos <- sweep(ctrl.rep2.zt.norm,1,min.ctrl.rep2.zt.norm,FUN = '-')
ctrl.rep3.zt.norm.pos <- sweep(ctrl.rep3.zt.norm,1,min.ctrl.rep3.zt.norm,FUN = '-')
```

sd-values and mean values of RNase:

```{r}
sd.rnase = apply(rnase.repz, 1, sd)

mean.rnase.rep1 <- apply(rnase.rep1z, 1, mean)
mean.rnase.rep2 <- apply(rnase.rep2z, 1, mean)
mean.rnase.rep3 <- apply(rnase.rep3z, 1, mean)
```

Normalization of RNase:

```{r}
rnase.rep1.meanvalue <- sweep(rnase.rep1z,1,mean.rnase.rep1,'-')
rnase.rep1.zt.norm <- sweep(rnase.rep1.meanvalue,1,sd.rnase,'/')

rnase.rep2.meanvalue <- sweep(rnase.rep2z,1,mean.rnase.rep2,'-')
rnase.rep2.zt.norm <- sweep(rnase.rep2.meanvalue,1,sd.rnase,'/')

rnase.rep3.meanvalue <- sweep(rnase.rep3z,1,mean.rnase.rep3,'-')
rnase.rep3.zt.norm <- sweep(rnase.rep3.meanvalue,1,sd.rnase,'/')

#calculate again the min value for each protein
min.rnase.rep1.zt.norm <- apply(rnase.rep1.zt.norm, 1, min)
min.rnase.rep2.zt.norm <- apply(rnase.rep2.zt.norm, 1, min)
min.rnase.rep3.zt.norm <- apply(rnase.rep3.zt.norm, 1, min)

#substract the min value from each position to discard the 0
rnase.rep1.zt.norm.pos <- sweep(rnase.rep1.zt.norm,1,min.rnase.rep1.zt.norm,FUN = '-')
rnase.rep2.zt.norm.pos <- sweep(rnase.rep2.zt.norm,1,min.rnase.rep2.zt.norm,FUN = '-')
rnase.rep3.zt.norm.pos <- sweep(rnase.rep3.zt.norm,1,min.rnase.rep3.zt.norm,FUN = '-')

```

#### 3.2.2. Scaling

We now scale the protein amount (= are under the curve) of each Replicate of Control to 100:

```{r}
ctrl.rep1.zt.scaled = 
  sweep(ctrl.rep1.zt.norm.pos,1,100/rowSums(ctrl.rep1.zt.norm.pos),'*')

ctrl.rep2.zt.scaled = 
  sweep(ctrl.rep2.zt.norm.pos,1,100/rowSums(ctrl.rep2.zt.norm.pos),'*')

ctrl.rep3.zt.scaled = 
  sweep(ctrl.rep3.zt.norm.pos,1,100/rowSums(ctrl.rep3.zt.norm.pos),'*')

ctrl.rep.zt.scaled = cbind(ctrl.rep1.zt.scaled,ctrl.rep2.zt.scaled,ctrl.rep3.zt.scaled)
```

And the protein amount (= are under the curve) of each Replicate of RNAse to 100:

```{r}
rnase.rep1.zt.scaled = 
  sweep(rnase.rep1.zt.norm.pos,1,100/rowSums(rnase.rep1.zt.norm.pos),'*')

rnase.rep2.zt.scaled = 
  sweep(rnase.rep2.zt.norm.pos,1,100/rowSums(rnase.rep2.zt.norm.pos),'*')

rnase.rep3.zt.scaled = 
  sweep(rnase.rep3.zt.norm.pos,1,100/rowSums(rnase.rep3.zt.norm.pos),'*')

rnase.rep.zt.scaled = cbind(rnase.rep1.zt.scaled,rnase.rep2.zt.scaled,rnase.rep3.zt.scaled)
```

#### 3.2.3. Reduction

Now we can set the replicates with poor correlation to NA.

```{r}

for (x in 1:dim(ctrl.rep.zt.scaled)[1]){
  if (ctrl.cor.removed[x, 1] < 0.9) {
    if (ctrl.cor.removed[x, 3] < 0.9){
      ctrl.rep.zt.scaled[x, 1:25] <- NA 
    }
    if (ctrl.cor.removed[x, 2] < 0.9){
      ctrl.rep.zt.scaled[x, 26:50] <- NA
    }}
  
  if (ctrl.cor.removed[x, 3] < 0.9) {
    if (ctrl.cor.removed[x, 2] < 0.9){
      ctrl.rep.zt.scaled[x, 51:75] <- NA
    }
  }
     }

for (x in 1:dim(rnase.rep.zt.scaled)[1]){
  if (rnase.cor.removed[x, 1] < 0.9) {
    if (rnase.cor.removed[x, 3] < 0.9){
      rnase.rep.zt.scaled[x, 1:25] <- NA 
    }
    if (rnase.cor.removed[x, 2] < 0.9){
      rnase.rep.zt.scaled[x, 26:50] <- NA
    }}
  
  if (rnase.cor.removed[x, 3] < 0.9) {
    if (rnase.cor.removed[x, 2] < 0.9){
      rnase.rep.zt.scaled[x, 51:75] <- NA
    }
  }
}

```

To unite the replicates we take the mean value between each replicate. Here we must consider the NA-values of non-reproducible replicates.

```{r}

r1c <- ctrl.rep1.zt.scaled
r2c <- ctrl.rep2.zt.scaled
r3c <- ctrl.rep3.zt.scaled

r1c0 <- ctrl.rep1.zt.scaled
r2c0 <- ctrl.rep2.zt.scaled
r3c0 <- ctrl.rep3.zt.scaled

r1c0[is.na(r1c)] <- 0
r2c0[is.na(r2c)] <- 0
r3c0[is.na(r3c)] <- 0

ctrl.zt.reduced.ns <-  (r1c0 + r2c0 + r3c0)/(3-((sum(is.na(r1c[x,]) + is.na(r2c[x,]) + is.na(r3c[x,])))/25))
```

```{r}

r1r <- rnase.rep1.zt.scaled
r2r <- rnase.rep2.zt.scaled
r3r <- rnase.rep3.zt.scaled

r1r0 <- rnase.rep1.zt.scaled
r2r0 <- rnase.rep2.zt.scaled
r3r0 <- rnase.rep3.zt.scaled

r1r0[is.na(r1r)] <- 0
r2r0[is.na(r2r)] <- 0
r3r0[is.na(r3r)] <- 0

rnase.zt.reduced.ns <-  (r1r0 + r2r0 + r3r0)/(3-((sum(is.na(r1r[x,]) + is.na(r2r[x,]) + is.na(r3r[x,])))/25))
```

Scaling of the reduced data set to 100.

```{r}
ctrl.zt.scaled = 
  sweep(ctrl.zt.reduced.ns,1,100/rowSums(ctrl.zt.reduced.ns),'*')
rnase.zt.scaled = 
  sweep(rnase.zt.reduced.ns,1,100/rowSums(rnase.zt.reduced.ns),'*')
```

Now we have normalized/scaled our data using z-transformation. The two variables that will be used later on either contain the normalized and scaled (zt) data of the control: **ctrl.zt** or the normalized and scaled (zt) data of the rnase: **rnase.zt**

```{r}
new.colnames.ctrl <- c("Fraction_1_Ctrl","Fraction_2_Ctrl","Fraction_3_Ctrl","Fraction_4_Ctrl","Fraction_5_Ctrl","Fraction_6_Ctrl","Fraction_7_Ctrl","Fraction_8_Ctrl","Fraction_9_Ctrl","Fraction_10_Ctrl","Fraction_11_Ctrl","Fraction_12_Ctrl","Fraction_13_Ctrl","Fraction_14_Ctrl","Fraction_15_Ctrl","Fraction_16_Ctrl","Fraction_17_Ctrl","Fraction_18_Ctrl","Fraction_19_Ctrl","Fraction_20_Ctrl","Fraction_21_Ctrl","Fraction_22_Ctrl","Fraction_23_Ctrl","Fraction_24_Ctrl","Fraction_25_Ctrl")
new.colnames.rnase <- c("Fraction_1_RNase","Fraction_2_RNase","Fraction_3_RNase","Fraction_4_RNase","Fraction_5_RNase","Fraction_6_RNase","Fraction_7_RNase","Fraction_8_RNase","Fraction_9_RNase","Fraction_10_RNase","Fraction_11_RNase","Fraction_12_RNase","Fraction_13_RNase","Fraction_14_RNase","Fraction_15_RNase","Fraction_16_RNase","Fraction_17_RNase","Fraction_18_RNase","Fraction_19_RNase","Fraction_20_RNase","Fraction_21_RNase","Fraction_22_RNase","Fraction_23_RNase","Fraction_24_RNase","Fraction_25_RNase")

ctrl.zt <- ctrl.zt.scaled
colnames(ctrl.zt) <- new.colnames.ctrl

rnase.zt <- rnase.zt.scaled
colnames(rnase.zt) <- new.colnames.rnase

# View(ctrl.zt)
# View(rnase.zt)
```

### 3.3. Min-Max-Scaling

#### 3.3.1. Normalization

We perform Min-Max-scaling (MMS) on each replicate, both control and RNase:

```{r}

# Control Replicate 1 MMS
ctrl.rep1.mms.norm <- t(apply(ctrl.rep1, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# Control Replicate 2 MMS
ctrl.rep2.mms.norm <- t(apply(ctrl.rep2, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# Control Replicate 3 MMS
ctrl.rep3.mms.norm <- t(apply(ctrl.rep3, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# RNase Replicate 1 MMS
rnase.rep1.mms.norm <- t(apply(rnase.rep1, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# RNase Replicate 2 MMS
rnase.rep2.mms.norm <- t(apply(rnase.rep2, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))

# RNase Replicate 2 MMS
rnase.rep3.mms.norm <- t(apply(rnase.rep3, 1, function(x) {
  normalized <- (x-min(x))/(max(x)-min(x))
}))
```


#### 3.3.2. Reduction

To unite the replicates, we take the mean value between each replicate. Here we must consider the NA-values of non-reproducible replicates.

```{r}

r1c <- ctrl.rep1.mms.norm
r2c <- ctrl.rep2.mms.norm
r3c <- ctrl.rep3.mms.norm

r1c0 <- ctrl.rep1.mms.norm
r2c0 <- ctrl.rep2.mms.norm
r3c0 <- ctrl.rep3.mms.norm

r1c0[is.na(r1c)] <- 0
r2c0[is.na(r2c)] <- 0
r3c0[is.na(r3c)] <- 0

ctrl.mms.reduced <-  (r1c0 + r2c0 + r3c0)/(3-((sum(as.numeric(is.na(r1c[x,])) + as.numeric(is.na(r2c[x,])) + as.numeric(is.na(r3c[x,]))))/25))

```

```{r}

r1r <- rnase.rep1.mms.norm
r2r <- rnase.rep2.mms.norm
r3r <- rnase.rep3.mms.norm

r1r0 <- rnase.rep1.mms.norm
r2r0 <- rnase.rep2.mms.norm
r3r0 <- rnase.rep3.mms.norm

r1r0[is.na(r1r)] <- 0
r2r0[is.na(r2r)] <- 0
r3r0[is.na(r3r)] <- 0

rnase.mms.reduced <-  (r1r0 + r2r0 + r3r0)/(3 - ((sum(as.numeric(is.na(r1r[x,])) + as.numeric(is.na(r2r[x,])) + as.numeric(is.na(r3r[x,]))))/25))

```

#### 3.3.3. Scaling

Those have to be scaled again:

```{r}
ctrl.mms.scaled <- t(apply(ctrl.mms.reduced, 1, function(x) {
  normalized <- ((x-min(x))/(max(x)-min(x)))*100
}))

rnase.mms.scaled <- t(apply(rnase.mms.reduced, 1, function(x){
  normalized <- ((x-min(x))/(max(x)-min(x)))*100
}))
```

Now we have normalized/scaled our data using min-max-scaling. The two variables that will be used later on either contain the normalized/scaled (mms) of the control: **ctrl.mms** or the normalized/scaled (mms) and scaled data of the rnase: **rnase.mms**

```{r}
new.colnames.ctrl <- c("Fraction_1_Ctrl","Fraction_2_Ctrl","Fraction_3_Ctrl","Fraction_4_Ctrl","Fraction_5_Ctrl","Fraction_6_Ctrl","Fraction_7_Ctrl","Fraction_8_Ctrl","Fraction_9_Ctrl","Fraction_10_Ctrl","Fraction_11_Ctrl","Fraction_12_Ctrl","Fraction_13_Ctrl","Fraction_14_Ctrl","Fraction_15_Ctrl","Fraction_16_Ctrl","Fraction_17_Ctrl","Fraction_18_Ctrl","Fraction_19_Ctrl","Fraction_20_Ctrl","Fraction_21_Ctrl","Fraction_22_Ctrl","Fraction_23_Ctrl","Fraction_24_Ctrl","Fraction_25_Ctrl")
new.colnames.rnase <- c("Fraction_1_RNase","Fraction_2_RNase","Fraction_3_RNase","Fraction_4_RNase","Fraction_5_RNase","Fraction_6_RNase","Fraction_7_RNase","Fraction_8_RNase","Fraction_9_RNase","Fraction_10_RNase","Fraction_11_RNase","Fraction_12_RNase","Fraction_13_RNase","Fraction_14_RNase","Fraction_15_RNase","Fraction_16_RNase","Fraction_17_RNase","Fraction_18_RNase","Fraction_19_RNase","Fraction_20_RNase","Fraction_21_RNase","Fraction_22_RNase","Fraction_23_RNase","Fraction_24_RNase","Fraction_25_RNase")

ctrl.mms <- ctrl.mms.scaled
colnames(ctrl.mms) <- new.colnames.ctrl
rnase.mms <- rnase.mms.scaled
colnames(rnase.mms) <- new.colnames.rnase

```

The result of this part are three times (Methods) two (Ctrl and RNase) normalized and scaled data frames: **ctrl.mvm**, **rnase.mvm**, **ctrl.zt**, **rnase.zt**, **ctrl.mms**, **rnase.mms**


## 4. Line Graphs

We start by plotting the amount of each protein in the 25 fractions for the RNase group. The plots are stored in plots_rnase.mvm, plots_rnase.zt, plots_rnase.mms.

```{r}
library(ggplot2)

num_rows <- nrow(rnase.mms)

plots_rnase.mvm <- list()
plots_rnase.zt <- list()
plots_rnase.mms <- list()
title = c("RNase MVM", "RNase z-Transformation", "RNase MMS")

row_data_rnase_all <- list(rnase.mvm, rnase.zt, rnase.mms)

for (d in 1:3){
  for (i in 1:num_rows) {
    row_data_rnase <- row_data_rnase_all[[d]][i,]
    
     if (sum(!is.na(row_data_rnase)) >= 2) {
      df <- data.frame(x = 1:length(row_data_rnase), yrnase = as.numeric(row_data_rnase))
      
      p <- ggplot(df, aes(x = x, y = yrnase)) +
      geom_line(color = "tomato") +
      geom_point(color = "tomato") +
      xlab("Fractions") +
      ylab("Protein amount")+
      labs(title = title[d])
      
      if (d == 3){plots_rnase.mms[[i]] <- p}
      if (d == 2){plots_rnase.zt[[i]] <- p}
      if (d == 1){plots_rnase.mvm[[i]] <- p}
    } else {
      if (d == 3){plots_rnase.mms[[i]] <- NULL}
      if (d == 2){plots_rnase.zt[[i]] <- NULL}
      if (d == 1){plots_rnase.mvm[[i]] <- NULL}

    }
  }
}
```

Next we create the plots for the Control. The plots are stored in plots_ctrl.mvm, plots_ctrl.zt, plots_ctrl.mms. 

```{r}
library(ggplot2)

num_rows <- nrow(ctrl.mms)

plots_ctrl.mvm <- list()
plots_ctrl.zt <- list()
plots_ctrl.mms <- list()

row_data_ctrl_all <- list(ctrl.mvm, ctrl.zt, ctrl.mms)
title <- c("Control MVM", "Control z-Transformation", "Control MMS")

for (d in 1:3) {
  for (i in 1:num_rows) {
    row_data_ctrl <- row_data_ctrl_all[[d]][i, ]
    
    if (sum(!is.na(row_data_ctrl)) >= 2) {
      df <- data.frame(x = 1:length(row_data_ctrl), yctrl = as.numeric(row_data_ctrl))
      
      p <- ggplot(df, aes(x = x, y = yctrl)) +
        geom_line(color = "skyblue2") +
        geom_point(color = "skyblue2") +
        xlab("Fractions") +
        ylab("Protein amount") +
        labs(title = title[d])
      
      if (d == 3) {plots_ctrl.mms[[i]] <- p}
      if (d == 2) { plots_ctrl.zt[[i]] <- p}
      if (d == 1) {plots_ctrl.mvm[[i]] <- p}
    } else {
      if (d == 3) {plots_ctrl.mms[[i]] <- NULL}
      if (d == 2) {plots_ctrl.zt[[i]] <- NULL}
      if (d == 1) {plots_ctrl.mvm[[i]] <- NULL}
    }
  }
}

```

The following code creates two plots in one diagram, so that the Control and RNase group can be compared.

```{r}
library(ggplot2)

num_rows <- nrow(ctrl.mms)

names.as.colum <- ctrl.mms
protein.names <- rownames(names.as.colum)

plots_ctrl_rnase.mvm <- list()
plots_ctrl_rnase.zt <- list()
plots_ctrl_rnase.mms <- list()

row_data_ctrl_all <- list(ctrl.mvm, ctrl.zt, ctrl.mms)
row_data_rnase_all <- list(rnase.mvm, rnase.zt, rnase.mms)

title <- c("Mean Value Method -", "z-Transformation -", "Min Max Scaling -")

for(b in 1:3){
  for (i in 1:num_rows) {
    row_data_ctrl <- row_data_ctrl_all[[b]][i, ]
    row_data_rnase <- row_data_rnase_all[[b]][i, ]
    
    if (sum(!is.na(row_data_ctrl)) >= 2) {
      df <- data.frame(x = 1:length(row_data_ctrl),yctrl= as.numeric(row_data_ctrl),yrnase= as.numeric(row_data_rnase))
      
      
      p <- ggplot(df, aes(x = x))+
        geom_line(aes(y=yrnase,color="RNASE"))+
        geom_point(aes(y=yrnase,color="RNASE"))+
        geom_line(aes(y=yctrl, color="CTRL"))+
        geom_point(aes(y=yctrl, color="CTRL"))+
        xlab("Fractions") +
        ylab("Protein amount") +
        labs(title = paste(title[b],protein.names[i])) +
        scale_color_manual(values = c("RNASE" = "tomato", "CTRL" = "skyblue2"))
      
      if (b == 3) {plots_ctrl_rnase.mms[[i]] <- p}
      if (b == 2) {plots_ctrl_rnase.zt[[i]] <- p}
      if (b == 1) {plots_ctrl_rnase.mvm[[i]] <- p}
    } else {
      if (b == 3) {plots_ctrl_rnase.mms[[i]] <- NULL}
      if (b == 2) {plots_ctrl_rnase.zt[[i]] <- NULL}
      if (b == 1) {plots_ctrl_rnase.mvm[[i]] <- NULL}
    }
  }
}
```

Here the plots can be printed. To print a specific protein, the row number it has in all the data frames must be written in the brackets. 

```{r}
plots_ctrl_rnase.mvm[[1030]]
plots_ctrl_rnase.zt[[1030]]
plots_ctrl_rnase.mms[[10]]
```



## 5. Peak Identification

### 5.1. Peaks for data set with mean value method - normalization

#### 5.1.1. Global Peaks

First the global peak identification for the control data set. We calculate the fraction and the protein amount under the global peak. Second we do the same for the rnase data set.

```{r}
globalpeak.ctrl.mvm <- apply(ctrl.mvm, 1, function(x){which.max(x)})
globalpeak.value.ctrl.mvm <- apply(ctrl.mvm, 1, function(x){max(x)})

globalpeak.rnase.mvm <- apply(rnase.mvm, 1, function(x){which.max(x)})
globalpeak.value.rnase.mvm <- apply(rnase.mvm, 1, function(x){max(x)})
```

#### 5.1.2. Local Peaks

First we have to calculate all the peaks, meaning global and local. We start again with the ctrl group. We start with calculating the sd to later sort out small fluctuations.

```{r}
peakidentif.ctrl.mvm <- ctrl.mvm
peakidentif.rnase.mvm <- rnase.mvm

sd.byrow.ctrl.mvm <- apply(peakidentif.ctrl.mvm, 1, function(x) sd(x[x < 8]))
sd.mean.ctrl.mvm <- mean(sd.byrow.ctrl.mvm)
sd.byrow.rnase.mvm <- apply(peakidentif.rnase.mvm, 1, function(x) sd(x[x < 8]))
sd.mean.rnase.mvm <- mean(sd.byrow.rnase.mvm)
```

Now we give the fractions new names. Thereby we take into regard that the length of peak_indices is shorter than the length of each row of our normalized data set. Afterwards we calculate each peak and look which did not occur as global peaks to identify the local peaks. Again starting with the control data set.

```{r}
colnames(peakidentif.ctrl.mvm) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.ctrl.mvm)) - 1)

allpeaks.ctrl.mvm <- apply(peakidentif.ctrl.mvm, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.ctrl.mvm]})

peak.values.ctrl.mvm <- lapply(seq_along(allpeaks.ctrl.mvm), function(i) peakidentif.ctrl.mvm[i, allpeaks.ctrl.mvm[[i]]])

localpeaks.ctrl.mvm <- allpeaks.ctrl.mvm 
for (i in seq_along(localpeaks.ctrl.mvm)) {localpeaks.ctrl.mvm[[i]] <- localpeaks.ctrl.mvm[[i]][!localpeaks.ctrl.mvm[[i]] %in% globalpeak.ctrl.mvm[[i]]]}

localpeaks.values.ctrl.mvm <- lapply(seq_along(localpeaks.ctrl.mvm), function(i) peakidentif.ctrl.mvm[i, localpeaks.ctrl.mvm[[i]]])
```

Here we do the same for the RNase group. 

```{r}
colnames(peakidentif.rnase.mvm) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.rnase.mvm)) - 1)

allpeaks.rnase.mvm <- apply(peakidentif.rnase.mvm, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.rnase.mvm]})

peak.values.rnase.mvm <- lapply(seq_along(allpeaks.rnase.mvm), function(i) peakidentif.rnase.mvm[i, allpeaks.rnase.mvm[[i]]])

localpeaks.rnase.mvm <- allpeaks.rnase.mvm 
for (i in seq_along(localpeaks.rnase.mvm)) {localpeaks.rnase.mvm[[i]] <- localpeaks.rnase.mvm[[i]][!localpeaks.rnase.mvm[[i]] %in% globalpeak.rnase.mvm[[i]]]}

localpeaks.values.rnase.mvm <- lapply(seq_along(localpeaks.rnase.mvm), function(i) peakidentif.rnase.mvm[i, localpeaks.rnase.mvm[[i]]])
```

#### 5.1.3. Boundaries

Futhermore, we have to look if there are peaks in fraction 1 or fraction 25. Again, we start with the identification of the boundaries for the control group.

```{r}
fraction1.peak.ctrl.mvm <- which(peakidentif.ctrl.mvm[, 1] > peakidentif.ctrl.mvm[, 2] & peakidentif.ctrl.mvm[, 1] > peakidentif.ctrl.mvm[, 3])


fraction25.peak.ctrl.mvm <- which(peakidentif.ctrl.mvm[, 25] > peakidentif.ctrl.mvm[, 24] & peakidentif.ctrl.mvm[, 25] > peakidentif.ctrl.mvm[, 23] & peakidentif.ctrl.mvm[, 25] + peakidentif.ctrl.mvm[, 24] +peakidentif.ctrl.mvm[, 23] > 10) 
```

And now the same for the RNase group. 

```{r}
fraction1.peak.rnase.mvm <- which(peakidentif.rnase.mvm[, 1] > peakidentif.rnase.mvm[, 2] & peakidentif.rnase.mvm[, 1] > peakidentif.rnase.mvm[, 3])

fraction25.peak.rnase.mvm <- which(peakidentif.rnase.mvm[, 25] > peakidentif.rnase.mvm[, 24] & peakidentif.rnase.mvm[, 25] > peakidentif.rnase.mvm[, 23] & peakidentif.rnase.mvm[, 25] + peakidentif.rnase.mvm[, 24] + peakidentif.rnase.mvm[, 23] > 10)

```

#### 5.1.4. Precipitated Proteins

At last we identify the precipitated proteins:

```{r}
precipitated.ctrl.mvm <- which(peakidentif.ctrl.mvm[, 25] > peakidentif.ctrl.mvm[, 24] & peakidentif.ctrl.mvm[, 25] > peakidentif.ctrl.mvm[, 23] & peakidentif.ctrl.mvm[, 25] + peakidentif.ctrl.mvm[, 24] + peakidentif.ctrl.mvm[, 23] == 100)

precipitated.rnase.mvm <- which(peakidentif.rnase.mvm[, 25] > peakidentif.rnase.mvm[, 24] & peakidentif.rnase.mvm[, 25] > peakidentif.rnase.mvm[, 23] & peakidentif.rnase.mvm[, 25] + peakidentif.rnase.mvm[, 24] + peakidentif.rnase.mvm[, 23] == 100)

precipitated.mvm <- unique(c(precipitated.ctrl.mvm,precipitated.rnase.mvm))
```

### 5.2. Peaks for data set with z_transformation - normalization

#### 5.2.1. Global Peak

First the global peak identification for the control data set. We calculate the fraction and the protein amount under the global peak. Second we do the same for the RNase data set.

```{r}
globalpeak.ctrl.zt <- apply(ctrl.zt, 1, function(x){which.max(x)})
globalpeak.value.ctrl.zt <- apply(ctrl.zt, 1, function(x){max(x)})

globalpeak.rnase.zt <- apply(rnase.zt, 1, function(x){which.max(x)})
globalpeak.value.rnase.zt <- apply(rnase.zt, 1, function(x){max(x)})
```

#### 5.2.2. Local Peaks

First we have to calculate all the peaks, meaning global and local. We start again with the ctrl group. We start with calculating the sd to later sort out small fluctuations.

```{r}
peakidentif.ctrl.zt <- ctrl.zt
peakidentif.rnase.zt <- rnase.zt

sd.byrow.ctrl.zt <- apply(peakidentif.ctrl.zt, 1, function(x) sd(x[x < 8]))
sd.mean.ctrl.zt <- mean(sd.byrow.ctrl.zt)
sd.byrow.rnase.zt <- apply(peakidentif.rnase.zt, 1, function(x) sd(x[x < 8]))
sd.mean.rnase.zt <- mean(sd.byrow.rnase.zt)
```

Now we give the fractions new names. Thereby we take into regard that the length of peak_indices is shorter than the length of each row of our normalized data set. Afterwards we calculate each peak and look which did not occur as global peaks to identify the local peaks. Again starting with the control data set.

```{r}
colnames(peakidentif.ctrl.zt) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.ctrl.zt)) - 1)

allpeaks.ctrl.zt <- apply(peakidentif.ctrl.zt, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.ctrl.zt]})

peak.values.ctrl.zt <- lapply(seq_along(allpeaks.ctrl.zt), function(i) peakidentif.ctrl.zt[i, allpeaks.ctrl.zt[[i]]])

localpeaks.ctrl.zt <- allpeaks.ctrl.zt 
for (i in seq_along(localpeaks.ctrl.zt)) {localpeaks.ctrl.zt[[i]] <- localpeaks.ctrl.zt[[i]][!localpeaks.ctrl.zt[[i]] %in% globalpeak.ctrl.zt[[i]]]}

localpeaks.values.ctrl.zt <- lapply(seq_along(localpeaks.ctrl.zt), function(i) peakidentif.ctrl.zt[i, localpeaks.ctrl.zt[[i]]])
```

Now the same for the RNase group.

```{r}
colnames(peakidentif.rnase.zt) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.rnase.zt)) - 1)

allpeaks.rnase.zt <- apply(peakidentif.rnase.zt, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.rnase.zt]})

peak.values.rnase.zt <- lapply(seq_along(allpeaks.rnase.zt), function(i) peakidentif.rnase.zt[i, allpeaks.rnase.zt[[i]]])

localpeaks.rnase.zt <- allpeaks.rnase.zt
for (i in seq_along(localpeaks.rnase.zt)) {localpeaks.rnase.zt[[i]] <- localpeaks.rnase.zt[[i]][!localpeaks.rnase.zt[[i]] %in% globalpeak.rnase.zt[[i]]]}

localpeaks.values.rnase.zt <- lapply(seq_along(localpeaks.rnase.zt), function(i) peakidentif.rnase.zt[i, localpeaks.rnase.zt[[i]]])
```

#### 5.2.3. Boundaries

Futhermore, we have to look if there are peaks in fraction 1 or fraction 25. Again, we start with the identification of the boundaries for the control group.

```{r}
fraction1.peak.ctrl.zt <- which(peakidentif.ctrl.zt[, 1] > peakidentif.ctrl.zt[, 2] & peakidentif.ctrl.zt[, 1] > peakidentif.ctrl.zt[, 3])

fraction25.peak.ctrl.zt <- which(peakidentif.ctrl.zt[, 25] > peakidentif.ctrl.zt[, 24] & peakidentif.ctrl.zt[, 25] > peakidentif.ctrl.zt[, 23] & peakidentif.ctrl.zt[, 25] + peakidentif.ctrl.zt[, 24] +peakidentif.ctrl.zt[, 23] > 10) 
```

```{r}
fraction1.peak.rnase.zt <- which(peakidentif.rnase.zt[, 1] > peakidentif.rnase.zt[, 2] & peakidentif.rnase.zt[, 1] > peakidentif.rnase.zt[, 3])

fraction25.peak.rnase.zt <- which(peakidentif.rnase.zt[, 25] > peakidentif.rnase.zt[, 24] & peakidentif.rnase.zt[, 25] > peakidentif.rnase.zt[, 23] & peakidentif.rnase.zt[, 25] + peakidentif.rnase.zt[, 24] + peakidentif.rnase.zt[, 23] > 10)
```

#### 5.2.4. Precipitated Proteins

At last we identify the precipitated proteins:

```{r}
precipitated.ctrl.zt <- which(peakidentif.ctrl.zt[, 25] > peakidentif.ctrl.zt[, 24] & peakidentif.ctrl.zt[, 25] > peakidentif.ctrl.zt[, 23] & peakidentif.ctrl.zt[, 25] + peakidentif.ctrl.zt[, 24] + peakidentif.ctrl.zt[, 23] == 100)

precipitated.rnase.zt <- which(peakidentif.rnase.zt[, 25] > peakidentif.rnase.zt[, 24] & peakidentif.rnase.zt[, 25] > peakidentif.rnase.zt[, 23] & peakidentif.rnase.zt[, 25] + peakidentif.rnase.zt[, 24] + peakidentif.rnase.zt[, 23] == 100)

precipitated.zt <- unique(c(precipitated.ctrl.zt,precipitated.rnase.zt))
```

### 5.3. Peaks for data set with min - max - scaling

#### 5.3.1. Global Peak

First the global peak identification for the control data set. We calculate the fraction and the protein amount under the global peak. Second we do the same for the rnase data set.

```{r}
globalpeak.ctrl.mms <- apply(ctrl.mms, 1, function(x){which.max(x)})
globalpeak.value.ctrl.mms <- apply(ctrl.mms, 1, function(x){max(x)})

globalpeak.rnase.mms <- apply(rnase.mms, 1, function(x){which.max(x)})
globalpeak.value.rnase.mms <- apply(rnase.mms, 1, function(x){max(x)})
```

#### 5.3.2. Local Peaks

First we have to calculate all the peaks, meaning global and local. We start again with the ctrl group. We start with calculating the sd to later sort out small fluctuations.

```{r}
peakidentif.ctrl.mms <- ctrl.mms
peakidentif.rnase.mms <- rnase.mms

sd.byrow.ctrl.mms <- apply(peakidentif.ctrl.mms, 1, function(x) sd(x[x < 8]))
sd.mean.ctrl.mms <- mean(sd.byrow.ctrl.mms)
sd.byrow.rnase.mms <- apply(peakidentif.rnase.mms, 1, function(x) sd(x[x < 8]))
sd.mean.rnase.mms <- mean(sd.byrow.rnase.mms)
```

Now we give the fractions new names. Thereby we take into regard that the length of peak_indices is shorter than the length of each row of our normalized data set. Afterwards we calculate each peak and look which did not occur as global peaks to identify the local peaks. Again starting with the control data set.

```{r}
colnames(peakidentif.ctrl.mms) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.ctrl.mms)) - 1)

allpeaks.ctrl.mms <- apply(peakidentif.ctrl.mms, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.ctrl.mms]})

peak.values.ctrl.mms <- lapply(seq_along(allpeaks.ctrl.mms), function(i) peakidentif.ctrl.mms[i, allpeaks.ctrl.mms[[i]]])

localpeaks.ctrl.mms <- allpeaks.ctrl.mms 
for (i in seq_along(localpeaks.ctrl.mms)) {localpeaks.ctrl.mms[[i]] <- localpeaks.ctrl.mms[[i]][!localpeaks.ctrl.mms[[i]] %in% globalpeak.ctrl.mms[[i]]]}

localpeaks.values.ctrl.mms <- lapply(seq_along(localpeaks.ctrl.mms), function(i) peakidentif.ctrl.mms[i, localpeaks.ctrl.mms[[i]]])
```

And the same for the RNase group:

```{r}
colnames(peakidentif.rnase.mms) <- paste0("Rnase_Fraction", seq_along(colnames(peakidentif.rnase.mms)) - 1)

allpeaks.rnase.mms <- apply(peakidentif.rnase.mms, 1,function(x) {
        peak_indices <- which(diff(sign(diff(x)))==-2 & x[-c(1,length(x))] > 3) + 1
        peak_sd <- sapply(peak_indices, function(i) sd(x[(i-1):(i+1)]))
             peak_indices[peak_sd > sd.mean.rnase.mms]})

peak.values.rnase.mms <- lapply(seq_along(allpeaks.rnase.mms), function(i) peakidentif.rnase.mms[i, allpeaks.rnase.mms[[i]]])

localpeaks.rnase.mms <- allpeaks.rnase.mms
for (i in seq_along(localpeaks.rnase.mms)) {localpeaks.rnase.mms[[i]] <- localpeaks.rnase.mms[[i]][!localpeaks.rnase.mms[[i]] %in% globalpeak.rnase.mms[[i]]]}

localpeaks.values.rnase.mms <- lapply(seq_along(localpeaks.rnase.mms), function(i) peakidentif.rnase.mms[i, localpeaks.rnase.mms[[i]]])
```


#### 5.3.3. Boundaries

Futhermore, we have to look if there are peaks in fraction 1 or fraction 25. Again, we start with the identification of the boundaries for the control group.

```{r}
fraction1.peak.ctrl.mms <- which(peakidentif.ctrl.mms[, 1] > peakidentif.ctrl.mms[, 2] & peakidentif.ctrl.mms[, 1] > peakidentif.ctrl.mms[, 3])

fraction25.peak.ctrl.mms <- which(peakidentif.ctrl.mms[, 25] > peakidentif.ctrl.mms[, 24] & peakidentif.ctrl.mms[, 25] > peakidentif.ctrl.mms[, 23] & peakidentif.ctrl.mms[, 25] + peakidentif.ctrl.mms[, 24] +peakidentif.ctrl.mms[, 23] > 10)
```

```{r}
fraction1.peak.rnase.mms <- which(peakidentif.rnase.mms[, 1] > peakidentif.rnase.mms[, 2] & peakidentif.rnase.mms[, 1] > peakidentif.rnase.mms[, 3])

fraction25.peak.rnase.mms <- which(peakidentif.rnase.mms[, 25] > peakidentif.rnase.mms[, 24] & peakidentif.rnase.mms[, 25] > peakidentif.rnase.mms[, 23] & peakidentif.rnase.mms[, 25] + peakidentif.rnase.mms[, 24] + peakidentif.rnase.mms[, 23] > 10)
```

#### 5.3.4. Precipitated Proteins

At last we identify the precipitated proteins:

```{r}
precipitated.ctrl.mms <- which(peakidentif.ctrl.mms[, 25] > peakidentif.ctrl.mms[, 24] & peakidentif.ctrl.mms[, 25] > peakidentif.ctrl.mms[, 23] & peakidentif.ctrl.mms[, 25] + peakidentif.ctrl.mms[, 24] + peakidentif.ctrl.mms[, 23] == 100)

precipitated.rnase.mms <- which(peakidentif.rnase.mms[, 25] > peakidentif.rnase.mms[, 24] & peakidentif.rnase.mms[, 25] > peakidentif.rnase.mms[, 23] & peakidentif.rnase.mms[, 25] + peakidentif.rnase.mms[, 24] + peakidentif.rnase.mms[, 23] == 100)

precipitated.mms <- unique(c(precipitated.ctrl.mms,precipitated.rnase.mms))
```


## 6. Gaussian fit

### 6.1 Gaussian fit for Mean Value Method normalized data

Defining relevant parameters for the gauss curve for all proteins of the Control group.

```{r}
num_rows <- nrow(ctrl.mvm)

parameter_gaussian_ctrl.mvm_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())

for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(ctrl.mvm[i,])
  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }
  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]
    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  initial_params <- c(1, 3, 1) 
  optimized_params <- optim(initial_params, fit_function)$par

  parameter_gaussian_ctrl.mvm_table <- rbind(parameter_gaussian_ctrl.mvm_table, optimized_params)
}
```

Defining relevant parameters for the gauss curve for all proteins of the RNase group.

```{r}
num_rows <- nrow(rnase.mvm)

parameter_gaussian_rnase.mvm_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())

for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(rnase.mvm[i,])

  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }

  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]

    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  initial_params <- c(1, 3, 1) 
  optimized_params <- optim(initial_params, fit_function)$par
  
  parameter_gaussian_rnase.mvm_table <- rbind(parameter_gaussian_rnase.mvm_table, optimized_params)
}
```

### 6.2 Gaussian fit for z-Transformation normalized data

Defining relevant parameters for the gauss curve for all proteins of the Control group.

```{r}
num_rows <- nrow(ctrl.zt)

parameter_gaussian_ctrl.zt_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())
 
for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(ctrl.zt[i,])

  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }

  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]
    
    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  initial_params <- c(1, 3, 1) 
  optimized_params <- optim(initial_params, fit_function)$par

  parameter_gaussian_ctrl.zt_table <- rbind(parameter_gaussian_ctrl.zt_table, optimized_params)
}
```

Defining relevant parameters for the gauss curve for all proteins of the RNase group.

```{r}
num_rows <- nrow(rnase.zt)

parameter_gaussian_rnase.zt_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())

for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(rnase.zt[i,])

  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }

  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]

    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  initial_params <- c(1, 3, 1) 
  optimized_params <- optim(initial_params, fit_function)$par
  
  parameter_gaussian_rnase.zt_table <- rbind(parameter_gaussian_rnase.zt_table, optimized_params)
}
```

### 6.3 Gaussian fit for Min-Max-Scaling normalized data

Defining relevant parameters for the gauss curve for all proteins of the Control group.

```{r}
num_rows <- nrow(ctrl.mms)

parameter_gaussian_ctrl.mms_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())
 
for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(ctrl.mms[i,])

  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }

  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]
    
    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  initial_params <- c(1, 3, 1) 
  optimized_params <- optim(initial_params, fit_function)$par

  parameter_gaussian_ctrl.mms_table <- rbind(parameter_gaussian_ctrl.mms_table, optimized_params)
}
```

Defining relevant parameters for the gauss curve for all proteins of the RNase group.

```{r}
num_rows <- nrow(rnase.mvm)

parameter_gaussian_rnase.mvm_table <- data.frame(a = numeric(),
                              mu = numeric(),
                              sigma = numeric())

for (i in 1:num_rows) {
  x <- c(1:25)
  y <- as.numeric(rnase.mvm[i,])

  gauss <- function(x, a, mu, sigma) {
    return(a * exp(-((x - mu)^2) / (2 * sigma^2)))
  }

  fit_function <- function(params) {
    a <- params[1]
    mu <- params[2]
    sigma <- params[3]

    squared_diff <- (gauss(x, a, mu, sigma) - y)^2
    sum_squared_diff <- sum(squared_diff)

    return(sum_squared_diff)
  }

  initial_params <- c(1, 3, 1) 
  optimized_params <- optim(initial_params, fit_function)$par
  
  parameter_gaussian_rnase.mvm_table <- rbind(parameter_gaussian_rnase.mvm_table, optimized_params)
}
```

###6.4 Plotting of gauss curves

####6.4.1 example of how to plot the curves for all proteins of the Control group

```{r}#
num_rows <- nrow(parameter_gaussian_ctrl.zt_table)
plots_gaussian_ctrl.zt <- list()
x <- c(1:25)
for (i in 1:num_rows) {
  a <- parameter_gaussian_ctrl.zt_table[i, 1]
  mu <- parameter_gaussian_ctrl.zt_table[i, 2]
  sigma <- parameter_gaussian_ctrl.zt_table[i, 3]
  row_data_gaussian_ctrl.zt <- parameter_gaussian_ctrl.zt_table[i, ]

  if (sum(!is.na(row_data_gaussian_ctrl.zt)) >= 2) {
    df <- data.frame(x = 1:length(row_data_gaussian_ctrl.zt), y = as.numeric(row_data_gaussian_ctrl.zt))

     #Erstellen eines neuen leeren Plots
    plot_new <- plot(NULL, xlim = c(min(x), max(x)), ylim = c(min(df$y), max(df$y)), 
                     xlab = "Fraction", ylab = "Protein amount", col = "palegreen2", lwd = 2)

     #Zeichnen der Kurve auf dem neuen Plot
    curve(gauss(x, a, mu, sigma), from = min(x), to = max(x), add = TRUE, col = "palegreen2", lwd = 2)

    # Speichern des neuen Plots in der Liste
    plots_gaussian_ctrl.zt[[i]] <- plot_new
    
  } else {
    plots_gaussian_ctrl.zt[[i]] <- NULL
  }

}
```


Here the Gaussian curves of control and RNase (z-transformation) are shown as an example. 

```{r}
n <- 9 # Number of protein you want to see
x <- c(1:25)
a1 <- parameter_gaussian_ctrl.zt_table[n, 1]
mu1 <- parameter_gaussian_ctrl.zt_table[n, 2]
sigma1 <- parameter_gaussian_ctrl.zt_table[n, 3]

a2 <- parameter_gaussian_rnase.zt_table[n, 1]
mu2 <- parameter_gaussian_rnase.zt_table[n, 2]
sigma2 <- parameter_gaussian_rnase.zt_table[n, 3]

plot(x, type = "n", ylim = c(0, 20), xlab = "Fractions", ylab = "Protein amount", col = "darkgrey")
title(main = paste("Gaussian fit ", rownames(rnase.zt)[n]))

curve(gauss(x, a = as.numeric(a1), mu = as.numeric(mu1), sigma = as.numeric(sigma1)), add = TRUE, col = "palegreen2", lwd = 2)
curve(gauss(x, a = as.numeric(a2), mu = as.numeric(mu2), sigma = as.numeric(sigma2)), add = TRUE, col = "violet", lwd = 2)

```



## 7. Parameters to identify RNA-dependent or RNA-binding Proteins 

### 7.1. Shifts

#### 7.1.1. Shifts with Mean Value Method

Here we identify the shifting proteins. In this case a shift of more than 2 Fraction is counted as RNA-dependent or RNA-binding.

```{r}
n = 2
shift_mvm_global <- globalpeak.rnase.mvm - globalpeak.ctrl.mvm

shift_mvm_named <- shift_mvm_global
for (i in 1:nrow(rnase.mvm)) {
  if (i %in% precipitated.mvm) {shift_mvm_named[i] <- "precipitated"}
  else if (shift_mvm_global [i] < (-n)){shift_mvm_named [i] <- "left shift"}
  else if (shift_mvm_global [i] > n){shift_mvm_named [i] <- "right shift"}
  else (shift_mvm_named [i] <- "no shift")
}

```

To be able to use the data whether a protein is clustered or not, we need to put it in a vector

```{r}
precipitated.mvm.v <- vector(mode = "numeric", length = dim(ctrl.mvm)[1])

for (i in 1:dim(ctrl.mvm)[1]){
  if (i %in% precipitated.mvm){
    precipitated.mvm.v[i] <- 1
  }
  else {
    precipitated.mvm.v[i] <- 0
  }
}
```

#### 7.1.2. Shifts with z-Transformation

In this case a shift of more than 2 Fraction is counted as RNA-dependent or RNA-binding.


```{r}
n = 2
shift_zt_global <- globalpeak.rnase.zt - globalpeak.ctrl.zt

shift_zt_named <- shift_zt_global
for (i in 1:nrow(ctrl.zt)) {
  if (i %in% precipitated.zt) {shift_zt_named[i] <- "precipitated"}
  else if (shift_zt_global [i] < (-n)){shift_zt_named [i] <- "left shift"}
  else if (shift_zt_global [i] > n){shift_zt_named [i] <- "right shift"}
  else (shift_zt_named [i] <- "no shift")
}

```

To be able to use the data whether a protein is clustered or not, we need to put it in a vector
```{r}
precipitated.zt.v <- vector(mode = "numeric", length = dim(ctrl.zt)[1])

for (i in 1:dim(ctrl.zt)[1]){
  if (i %in% precipitated.zt){
    precipitated.zt.v[i] <- 1
  }
  else {
    precipitated.zt.v[i] <- 0
  }
}
```


#### 7.1.3. Shifts with Min-Max Scaling

In this case a shift of more than 2 Fraction is counted as RNA-dependent or RNA-binding.

```{r}
n = 2
shift_mms_global <- globalpeak.rnase.mms - globalpeak.ctrl.mms

shift_mms_named <- shift_mms_global
for (i in 1:nrow(ctrl.mms)) {
  if (i %in% precipitated.mms) {shift_mms_named[i] <- "precipitated"}
  else if (shift_mms_global [i] < (-n)){shift_mms_named [i] <- "left shift"}
  else if (shift_mms_global [i] > n){shift_mms_named [i] <- "right shift"}
  else (shift_mms_named [i] <- "no shift")
}

```

To be able to use the data whether a protein is clustered or not, we need to put it in a vector
```{r}
precipitated.mms.v <- vector(mode = "numeric", length = dim(ctrl.mms)[1])

for (i in 1:dim(ctrl.mms)[1]){
  if (i %in% precipitated.mms){
    precipitated.mms.v[i] <- 1
  }
  else {
    precipitated.mms.v[i] <- 0
  }
}

```

### 7.2 Shoulderregions

#### 7.2.1 Shoulderregions based on Mean-Value-Method

Proteins can also be RNA dependent even if they do not have a significant shift. The protein amount can changes significantly without an shift. One indicator could be the appearance of a shoulder regions.

```{r}
shreg.rnase.mvm <- rnase.mvm
```


First, we identify fractions (regions) of proteins with high protein amount. 

```{r}
largevalues.rnase.mvm <- apply(shreg.rnase.mvm[,2:24], 1, function(x) {
  largevalues_indices <- which(x > 4.5) + 1 # to start again with 2
  peak_mean <- sapply(largevalues_indices, function(i) mean(x[(i-1):(i+1)]))
  largevalues_indices <- largevalues_indices[peak_mean > 4.5]
  unique(c(largevalues_indices - 1 , largevalues_indices, largevalues_indices + 1))
})
```

Now, all regions (= 3 fractions) with a sd smaller then the sd for our normal fluctuation used by peak identification are selected.

```{r}
closereg.rnase.mvm <- list()
for (i in 1:nrow(shreg.rnase.mvm)) {
  row <- shreg.rnase.mvm[i,]
  indices <- c()
  
  for (j in 1:(ncol(shreg.rnase.mvm)-2)) {
    values <- as.numeric(row[j:(j+2)])
    
    if (sd(values) < sd.mean.rnase.mvm) { 
      indices <- c(indices, j:(j+2))}}
 
    if (length(indices) == 0) {
    closereg.rnase.mvm[[i]] <- numeric(0)}
    
    else {closereg.rnase.mvm[[i]] <- indices}}
```

We just want to have the large values which also occur in close value.

```{r}
largevalues.closereg.rnase.mvm <- largevalues.rnase.mvm
for (i in seq_along(largevalues.closereg.rnase.mvm)) {
    largevalues.closereg.rnase.mvm[[i]] <- largevalues.closereg.rnase.mvm[[i]][largevalues.closereg.rnase.mvm[[i]] %in% closereg.rnase.mvm[[i]]]}
ordered.largevalues.closereg.rnase.mvm <- lapply(largevalues.closereg.rnase.mvm,function(row){sort(row)})
```

Here, the shoulderregions are identified, using the previously defined variables.

```{r}
shoulderregion.rnase.mvm <- lapply(ordered.largevalues.closereg.rnase.mvm,function(x) {
    diffs <- c(1, diff(x))
    groups <- rle(diffs)
    shoulderregion <- which(groups$values == 1 & groups$lengths >= 2)
    if (length(shoulderregion) > 0) {
        starts <- cumsum(groups$lengths)[shoulderregion] - groups$lengths[shoulderregion] 
        ends <- cumsum(groups$lengths)[shoulderregion]
        shoulderregion <- mapply(function(start, end) x[start:end], starts, ends)
    }
    return(shoulderregion)
})
```

We continue with the ctrl group.

```{r}
shreg.ctrl.mvm <- ctrl.mvm
```

First, we identify fraction (regions) of proteins with high protein amount. 

```{r}
largevalues.ctrl.mvm <- apply(shreg.ctrl.mvm[,2:24], 1, function(x) {
  largevalues_indices <- which(x > 4.5) + 1 # to start again with 2
  peak_mean <- sapply(largevalues_indices, function(i) mean(x[(i-1):(i+1)]))
  largevalues_indices <- largevalues_indices[peak_mean > 4.5]
  unique(c(largevalues_indices - 1 , largevalues_indices, largevalues_indices + 1))
})
```

```{r}
closereg.ctrl.mvm <- list()
for (i in 1:nrow(shreg.ctrl.mvm)) {
  row <- shreg.ctrl.mvm[i,]
  indices <- c()
  
  for (j in 1:(ncol(shreg.ctrl.mvm)-2)) {
    values <- as.numeric(row[j:(j+2)])
    
    if (sd(values) < sd.mean.ctrl.mvm) { 
      indices <- c(indices, j:(j+2))}}
 
    if (length(indices) == 0) {
    closereg.ctrl.mvm[[i]] <- numeric(0)}
    
    else {closereg.ctrl.mvm[[i]] <- indices}}
```

We just want to have the large values which also occur in close value.

```{r}
largevalues.closereg.ctrl.mvm <- largevalues.ctrl.mvm
for (i in seq_along(largevalues.closereg.ctrl.mvm)) {
    largevalues.closereg.ctrl.mvm[[i]] <- largevalues.closereg.ctrl.mvm[[i]][largevalues.closereg.ctrl.mvm[[i]] %in% closereg.ctrl.mvm[[i]]]}
ordered.largevalues.closereg.ctrl.mvm <- lapply(largevalues.closereg.ctrl.mvm,function(row){sort(row)})
```

Here, the shoulderregions are identified, using the previously defined variables.

```{r}
shoulderregion.ctrl.mvm <- lapply(ordered.largevalues.closereg.ctrl.mvm,function(x) {
    diffs <- c(1, diff(x))
    groups <- rle(diffs)
    shoulderregion <- which(groups$values == 1 & groups$lengths >= 2)
    if (length(shoulderregion) > 0) {
        starts <- cumsum(groups$lengths)[shoulderregion] - groups$lengths[shoulderregion] 
        ends <- cumsum(groups$lengths)[shoulderregion]
        shoulderregion <- mapply(function(start, end) x[start:end], starts, ends)
    }
    return(shoulderregion)
})
```

Now we can find shoulderregions which only occur in one sample (ctrl or rnase). 

```{r}
shoulderregion.a.mvm <- lapply(names(shoulderregion.ctrl.mvm), function(x) setdiff(shoulderregion.ctrl.mvm[[x]], shoulderregion.rnase.mvm[[x]]))
names(shoulderregion.a.mvm) <- names(shoulderregion.ctrl.mvm)

shoulderregion.b.mvm <- lapply(names(shoulderregion.rnase.mvm), function(x) setdiff(shoulderregion.rnase.mvm[[x]], shoulderregion.ctrl.mvm[[x]]))
names(shoulderregion.b.mvm) <- names(shoulderregion.rnase.mvm)
```

At last, we only want does proteins with entries more than 2. The others have no significant difference.

```{r}
selec.shoulderregion.a.mvm <- lapply(shoulderregion.a.mvm, function(x) 
  if (length(x) < 3) {return(numeric(0))} 
  else {return(x)})

selec.shoulderregion.b.mvm <- lapply(shoulderregion.b.mvm, function(x) 
  if (length(x) < 3) {return(numeric(0))} 
  else {return(x)})
```

To include the shoulder regions into the dataframe with parameters, we create a new dataframe with 0 for shoulderregion and 1 with shoulderregion.

```{r}
selec.shoulderregion.a.1.mvm <- lapply(shoulderregion.a.mvm, function(x) 
  if (length(x) > 2) {return (1)} 
  else {return(0)})

selec.shoulderregion.b.1.mvm <- lapply(shoulderregion.b.mvm, function(x) 
  if (length(x) > 2) {return (1)} 
  else {return(0)})

shoulderregion.mvm.1.nt <- as.data.frame(selec.shoulderregion.a.1.mvm)
shoulderregion.mvm.2.nt <- as.data.frame(selec.shoulderregion.b.1.mvm)

shoulderregion.mvm.nt <- shoulderregion.mvm.1.nt + shoulderregion.mvm.2.nt

shoulderregion.mvm.nt.nt <- data.frame(lapply(shoulderregion.mvm.nt, function(x) ifelse(x == 2, 1, x)))

ShoulderRegion_mvm <- t(shoulderregion.mvm.nt.nt)

# View(ShoulderRegion_mvm)
```

#### 7.2.2 Shoulderregions based on z-Transformed values

Proteins can also be RNA dependent even if they do not have a significant shift. The protein amount can changes significantly without an shift. One indicator could be the appearance of a shoulder regions.

```{r}
shreg.rnase.zt <- rnase.zt
```


First, we identify fraction (regions) of proteins with high protein amount. 
```{r}
largevalues.rnase.zt <- apply(shreg.rnase.zt[,2:24], 1, function(x) {
  largevalues_indices <- which(x > 4.5) + 1 # to start again with 2
  peak_mean <- sapply(largevalues_indices, function(i) mean(x[(i-1):(i+1)]))
  largevalues_indices <- largevalues_indices[peak_mean > 4.5]
  unique(c(largevalues_indices - 1 , largevalues_indices, largevalues_indices + 1))
})
```

Identification of regions around the peaks.

```{r}
neighpeaks.rnase.zt <- apply(shreg.rnase.zt, 1,
            function(x) { peak_indices <- which(diff(sign(diff(x))) == -2 & x[-c(1, length(x))] > 3) + 1
              peak_sd <- sapply(peak_indices,function(i) sd(x[(i-1):(i+1)]))
              peak_indices <- peak_indices[peak_sd > sd.mean.rnase.zt]
              c(peak_indices - 1, peak_indices, peak_indices + 1)})
```

Now we identify the boundaries again, but safe them in a list.

```{r}
boundary1.rnase.zt <- lapply(1:nrow(shreg.rnase.zt), function(i) {
  if (shreg.rnase.zt[i, 1] > shreg.rnase.zt[i, 2] & shreg.rnase.zt[i, 1] > shreg.rnase.zt[i, 3] & (shreg.rnase.zt[i, 1] + shreg.rnase.zt[i, 2] + shreg.rnase.zt[i, 3]) > 10) {
    return(c(1,2,3))} 
    else {
    return(numeric(0))}
})

boundary25.rnase.zt <-lapply(1:nrow(shreg.rnase.zt), function(i) {
  if (shreg.rnase.zt[i, 25] > shreg.rnase.zt[i, 24] & shreg.rnase.zt[i, 25] > shreg.rnase.zt[i, 23] & (shreg.rnase.zt[i, 25] + shreg.rnase.zt[i, 24] + shreg.rnase.zt[i, 23]) > 10) {
    return(c(25,24,23))} 
    else {
    return(numeric(0))}
})
```

Now, all regions (= 3 fractions) with a sd smaller then the sd for our normal fluctuation used by peak identification are selected.

```{r}
closereg.rnase.zt <- list()
for (i in 1:nrow(shreg.rnase.zt)) {
  row <- shreg.rnase.zt[i,]
  indices <- c()
  
  for (j in 1:(ncol(shreg.rnase.zt)-2)) {
    values <- as.numeric(row[j:(j+2)])
    
    if (sd(values) < sd.mean.rnase.zt) { 
      indices <- c(indices, j:(j+2))}}
 
    if (length(indices) == 0) {
    closereg.rnase.zt[[i]] <- numeric(0)}
    
    else {closereg.rnase.zt[[i]] <- indices}}
```

We just want to have the large values which also occur in close value.

```{r}
largevalues.closereg.rnase.zt <- largevalues.rnase.zt
for (i in seq_along(largevalues.closereg.rnase.zt)) {
    largevalues.closereg.rnase.zt[[i]] <- largevalues.closereg.rnase.zt[[i]][largevalues.closereg.rnase.zt[[i]] %in% closereg.rnase.zt[[i]]]}
ordered.largevalues.closereg.rnase.zt <- lapply(largevalues.closereg.rnase.zt,function(row){sort(row)})
```

Here, the shoulderregions are identified, using the previously defined variables.

```{r}
shoulderregion.rnase.zt <- lapply(ordered.largevalues.closereg.rnase.zt,function(x) {
    diffs <- c(1, diff(x))
    groups <- rle(diffs)
    shoulderregion <- which(groups$values == 1 & groups$lengths >= 2)
    if (length(shoulderregion) > 0) {
        starts <- cumsum(groups$lengths)[shoulderregion] - groups$lengths[shoulderregion] 
        ends <- cumsum(groups$lengths)[shoulderregion]
        shoulderregion <- mapply(function(start, end) x[start:end], starts, ends)
    }
    return(shoulderregion)
})
```


We continue with the ctrl group.
```{r}
shreg.ctrl.zt <- ctrl.zt
```

First, we identify fraction (regions) of proteins with high protein amount. 
```{r}
largevalues.ctrl.zt <- apply(shreg.ctrl.zt[,2:24], 1, function(x) {
  largevalues_indices <- which(x > 4.5) + 1 # to start again with 2
  peak_mean <- sapply(largevalues_indices, function(i) mean(x[(i-1):(i+1)]))
  largevalues_indices <- largevalues_indices[peak_mean > 4.5]
  unique(c(largevalues_indices - 1 , largevalues_indices, largevalues_indices + 1))
})
```

```{r}
closereg.ctrl.zt <- list()
for (i in 1:nrow(shreg.ctrl.zt)) {
  row <- shreg.ctrl.zt[i,]
  indices <- c()
  
  for (j in 1:(ncol(shreg.ctrl.zt)-2)) {
    values <- as.numeric(row[j:(j+2)])
    
    if (sd(values) < sd.mean.ctrl.zt) { 
      indices <- c(indices, j:(j+2))}}
 
    if (length(indices) == 0) {
    closereg.ctrl.zt[[i]] <- numeric(0)}
    
    else {closereg.ctrl.zt[[i]] <- indices}}
```

We just want to have the large values which also occur in close value.

```{r}
largevalues.closereg.ctrl.zt <- largevalues.ctrl.zt
for (i in seq_along(largevalues.closereg.ctrl.zt)) {
    largevalues.closereg.ctrl.zt[[i]] <- largevalues.closereg.ctrl.zt[[i]][largevalues.closereg.ctrl.zt[[i]] %in% closereg.ctrl.zt[[i]]]}
ordered.largevalues.closereg.ctrl.zt <- lapply(largevalues.closereg.ctrl.zt,function(row){sort(row)})
```

Here, the shoulderregions are identified, using the previously defined variables.

```{r}
shoulderregion.ctrl.zt <- lapply(ordered.largevalues.closereg.ctrl.zt,function(x) {
    diffs <- c(1, diff(x))
    groups <- rle(diffs)
    shoulderregion <- which(groups$values == 1 & groups$lengths >= 2)
    if (length(shoulderregion) > 0) {
        starts <- cumsum(groups$lengths)[shoulderregion] - groups$lengths[shoulderregion] 
        ends <- cumsum(groups$lengths)[shoulderregion]
        shoulderregion <- mapply(function(start, end) x[start:end], starts, ends)
    }
    return(shoulderregion)
})
```

Now we can find shoulderregions which only occur in one sample (ctrl or rnase). 

```{r}
shoulderregion.a.zt <- lapply(names(shoulderregion.ctrl.zt), function(x) setdiff(shoulderregion.ctrl.zt[[x]], shoulderregion.rnase.zt[[x]]))
names(shoulderregion.a.zt) <- names(shoulderregion.ctrl.zt)

shoulderregion.b.zt <- lapply(names(shoulderregion.rnase.zt), function(x) setdiff(shoulderregion.rnase.zt[[x]], shoulderregion.ctrl.zt[[x]]))
names(shoulderregion.b.zt) <- names(shoulderregion.rnase.zt)
```

At last, we only want does proteins with entries more than 2. The others have no significant difference.

```{r}
selec.shoulderregion.a.zt <- lapply(shoulderregion.a.zt, function(x) 
  if (length(x) < 3) {return(numeric(0))} 
  else {return(x)})

selec.shoulderregion.b.zt <- lapply(shoulderregion.b.zt, function(x) 
  if (length(x) < 3) {return(numeric(0))} 
  else {return(x)})
```

To include the shoulder regions into the dataframe with parameters, we create a new dataframe with 0 for shoulderregion and 1 with shoulderregion.

```{r}
selec.shoulderregion.a.1.zt <- lapply(shoulderregion.a.zt, function(x) 
  if (length(x) > 2) {return (1)} 
  else {return(0)})

selec.shoulderregion.b.1.zt <- lapply(shoulderregion.b.zt, function(x) 
  if (length(x) > 2) {return (1)} 
  else {return(0)})

shoulderregion.zt.1.nt <- as.data.frame(selec.shoulderregion.a.1.zt)
shoulderregion.zt.2.nt <- as.data.frame(selec.shoulderregion.b.1.zt)

shoulderregion.zt.nt <- shoulderregion.zt.1.nt + shoulderregion.zt.2.nt

shoulderregion.zt.nt.nt <- data.frame(lapply(shoulderregion.zt.nt, function(x) ifelse(x == 2, 1, x)))

ShoulderRegion_zt <- t(shoulderregion.zt.nt.nt)

```

#### 7.2.3 Shoulderregions based on Min-Max-Scaling

Proteins can also be RNA dependent even if they do not have a significant shift. The protein amount can changes significantly without an shift. One indicator could be the appearance of a shoulder regions.

```{r}
shreg.rnase.mms <- rnase.mms
```


First, we identify fraction (regions) of proteins with high protein amount. 
```{r}
largevalues.rnase.mms <- apply(shreg.rnase.mms[,2:24], 1, function(x) {
  largevalues_indices <- which(x > 4.5) + 1 # to start again with 2
  peak_mean <- sapply(largevalues_indices, function(i) mean(x[(i-1):(i+1)]))
  largevalues_indices <- largevalues_indices[peak_mean > 4.5]
  unique(c(largevalues_indices - 1 , largevalues_indices, largevalues_indices + 1))
})
```

Now, all regions (= 3 fractions) with a sd smaller then the sd for our normal fluctuation used by peak identification are selected.
```{r}
closereg.rnase.mms <- list()
for (i in 1:nrow(shreg.rnase.mms)) {
  row <- shreg.rnase.mms[i,]
  indices <- c()
  
  for (j in 1:(ncol(shreg.rnase.mms)-2)) {
    values <- as.numeric(row[j:(j+2)])
    
    if (sd(values) < sd.mean.rnase.mms) { 
      indices <- c(indices, j:(j+2))}}
 
    if (length(indices) == 0) {
    closereg.rnase.mms[[i]] <- numeric(0)}
    
    else {closereg.rnase.mms[[i]] <- indices}}
```

We just want to have the large values which also occur in close value.
```{r}
largevalues.closereg.rnase.mms <- largevalues.rnase.mms
for (i in seq_along(largevalues.closereg.rnase.mms)) {
    largevalues.closereg.rnase.mms[[i]] <- largevalues.closereg.rnase.mms[[i]][largevalues.closereg.rnase.mms[[i]] %in% closereg.rnase.mms[[i]]]}
ordered.largevalues.closereg.rnase.mms <- lapply(largevalues.closereg.rnase.mms,function(row){sort(row)})
```

Here, the shoulderregions are identified, using the previously defined variables.

```{r}
shoulderregion.rnase.mms <- lapply(ordered.largevalues.closereg.rnase.mms,function(x) {
    diffs <- c(1, diff(x))
    groups <- rle(diffs)
    shoulderregion <- which(groups$values == 1 & groups$lengths >= 2)
    if (length(shoulderregion) > 0) {
        starts <- cumsum(groups$lengths)[shoulderregion] - groups$lengths[shoulderregion] 
        ends <- cumsum(groups$lengths)[shoulderregion]
        shoulderregion <- mapply(function(start, end) x[start:end], starts, ends)
    }
    return(shoulderregion)
})
```

We continue with the ctrl group.
```{r}
shreg.ctrl.mms <- ctrl.mms
```

First, we identify fraction (regions) of proteins with high protein amount. 
```{r}
largevalues.ctrl.mms <- apply(shreg.ctrl.mms[,2:24], 1, function(x) {
  largevalues_indices <- which(x > 4.5) + 1 # to start again with 2
  peak_mean <- sapply(largevalues_indices, function(i) mean(x[(i-1):(i+1)]))
  largevalues_indices <- largevalues_indices[peak_mean > 4.5]
  unique(c(largevalues_indices - 1 , largevalues_indices, largevalues_indices + 1))
})
```

```{r}
closereg.ctrl.mms <- list()
for (i in 1:nrow(shreg.ctrl.mms)) {
  row <- shreg.ctrl.mms[i,]
  indices <- c()
  
  for (j in 1:(ncol(shreg.ctrl.mms)-2)) {
    values <- as.numeric(row[j:(j+2)])
    
    if (sd(values) < sd.mean.ctrl.mms) { 
      indices <- c(indices, j:(j+2))}}
 
    if (length(indices) == 0) {
    closereg.ctrl.mms[[i]] <- numeric(0)}
    
    else {closereg.ctrl.mms[[i]] <- indices}}
```

We just want to have the large values which also occur in close value.

```{r}
largevalues.closereg.ctrl.mms <- largevalues.ctrl.mms
for (i in seq_along(largevalues.closereg.ctrl.mms)) {
    largevalues.closereg.ctrl.mms[[i]] <- largevalues.closereg.ctrl.mms[[i]][largevalues.closereg.ctrl.mms[[i]] %in% closereg.ctrl.mms[[i]]]}
ordered.largevalues.closereg.ctrl.mms <- lapply(largevalues.closereg.ctrl.mms,function(row){sort(row)})
```

Here, the shoulderregions are identified, using the previously defined variables.

```{r}
shoulderregion.ctrl.mms <- lapply(ordered.largevalues.closereg.ctrl.mms,function(x) {
    diffs <- c(1, diff(x))
    groups <- rle(diffs)
    shoulderregion <- which(groups$values == 1 & groups$lengths >= 2)
    if (length(shoulderregion) > 0) {
        starts <- cumsum(groups$lengths)[shoulderregion] - groups$lengths[shoulderregion] 
        ends <- cumsum(groups$lengths)[shoulderregion]
        shoulderregion <- mapply(function(start, end) x[start:end], starts, ends)
    }
    return(shoulderregion)
})
```

Now we can find shoulderregions which only occur in one sample (ctrl or rnase). 

```{r}
shoulderregion.a.mms <- lapply(names(shoulderregion.ctrl.mms), function(x) setdiff(shoulderregion.ctrl.mms[[x]], shoulderregion.rnase.mms[[x]]))
names(shoulderregion.a.mms) <- names(shoulderregion.ctrl.mms)

shoulderregion.b.mms <- lapply(names(shoulderregion.rnase.mms), function(x) setdiff(shoulderregion.rnase.mms[[x]], shoulderregion.ctrl.mms[[x]]))
names(shoulderregion.b.mms) <- names(shoulderregion.rnase.mms)
```

At last, we only want does proteins with entries more than 2. The others have no significant difference.

```{r}
selec.shoulderregion.a.mms <- lapply(shoulderregion.a.mms, function(x) 
  if (length(x) < 3) {return(numeric(0))} 
  else {return(x)})

selec.shoulderregion.b.mms <- lapply(shoulderregion.b.mms, function(x) 
  if (length(x) < 3) {return(numeric(0))} 
  else {return(x)})
```

To include the shoulder regions into the dataframe with parameters, we create a new dataframe with 0 for shoulderregion and 1 with shoulderregion.

```{r}
selec.shoulderregion.a.1.mms <- lapply(shoulderregion.a.mvm, function(x) 
  if (length(x) > 2) {return (1)} 
  else {return(0)})

selec.shoulderregion.b.1.mms <- lapply(shoulderregion.b.mms, function(x) 
  if (length(x) > 2) {return (1)} 
  else {return(0)})

shoulderregion.mms.1.nt <- as.data.frame(selec.shoulderregion.a.1.mms)
shoulderregion.mms.2.nt <- as.data.frame(selec.shoulderregion.b.1.mms)

shoulderregion.mms.nt <- shoulderregion.mms.1.nt + shoulderregion.mms.2.nt

shoulderregion.mms.nt.nt <- data.frame(lapply(shoulderregion.mms.nt, function(x) ifelse(x == 2, 1, x)))

ShoulderRegion_mms <- t(shoulderregion.mms.nt.nt)

```


### 7.3 Protein amount under global peak

#### 7.3.1 protein amount under global peak based on Mean-Value-Methode

We can test for proteins with a significant higher protein amount under the global peaks in the RNase group.

```{r}
signi.global.pa.mvm <- data.frame(PA_global = ifelse(globalpeak.value.rnase.mvm > 1.7 * globalpeak.value.ctrl.mvm | globalpeak.value.ctrl.mvm > 1.7 * globalpeak.value.rnase.mvm, 1, 0))

rownames(signi.global.pa.mvm) <- rownames(rnase.mvm)

```
#### 7.3.2 protein amount under global peaks shift based on z-Transformation

We can do the the same for z-transformation.

```{r}
signi.global.pa.zt <- data.frame(PA_global = ifelse(globalpeak.value.rnase.zt > 1.7 * globalpeak.value.ctrl.zt | globalpeak.value.ctrl.zt > 1.7 * globalpeak.value.rnase.zt, 1, 0))

rownames(signi.global.pa.zt) <- rownames(rnase.zt)

```

#### 7.3.3 protein amount under global peaks shift based on Min-Max-Scaling

With this method we can´t find any Rdeeps for the mms normalized data because all protein amount under the global peaks of the control and the RNase group are 100. 


### 7.4 Protein amount under local peaks shift 

#### 7.4.1 Protein amount under local peaks shift based on Mean-Value-Method

First we have to sum up the protein amount under all local peaks - for the control group.

```{r}
localpeaks.sumvalues.ctrl.mvm <- data.frame(sum_values = numeric(length(localpeaks.values.ctrl.mvm)))

for (i in seq_along(localpeaks.values.ctrl.mvm)) {
  sum_values <- sum(localpeaks.values.ctrl.mvm[[i]])
  localpeaks.sumvalues.ctrl.mvm[i, "sum_values"] <- sum_values}

```

Protein amount under all local peaks - for the RNase group. 

```{r}
localpeaks.sumvalues.rnase.mvm <- data.frame(sum_values = numeric(length(localpeaks.values.rnase.mvm)))

for (i in seq_along(localpeaks.values.rnase.mvm)) {
  sum_values <- sum(localpeaks.values.rnase.mvm[[i]])
  localpeaks.sumvalues.rnase.mvm[i, "sum_values"] <- sum_values}
 
```

Then we can test for proteins with a significant higher protein amount under the local peaks in the RNase group.

```{r}
signi.local.pa.mvm <- data.frame(PA_local = rep(0, nrow(localpeaks.sumvalues.rnase.mvm)))

for (i in 1:nrow(localpeaks.sumvalues.rnase.mvm)) {
  if (abs(localpeaks.sumvalues.rnase.mvm$sum_values[i] - localpeaks.sumvalues.ctrl.mvm$sum_values[i]) > 7.5)
  {
    signi.local.pa.mvm$PA_local[i] <- 1
  }
}

rownames(signi.local.pa.mvm) <- rownames(rnase.mvm)

```

#### 7.4.2 protein amount under local peaks shift based on z-Transformation

First we have to sum up the protein amount under all local peaks - for the control group.

```{r}
localpeaks.sumvalues.ctrl.zt <- data.frame(Summed_Values = numeric(length(localpeaks.values.ctrl.zt)))

for (i in seq_along(localpeaks.values.ctrl.zt)) {
  summed_values <- sum(localpeaks.values.ctrl.zt[[i]])
  localpeaks.sumvalues.ctrl.zt[i, "Summed_Values"] <- summed_values
}

```

Protein amount under all local peaks - for the RNase group. 

```{r}
localpeaks.sumvalues.rnase.zt <- data.frame(Summed_Values = numeric(length(localpeaks.values.rnase.zt)))

for (i in seq_along(localpeaks.values.rnase.zt)) {
  summed_values <- sum(localpeaks.values.rnase.zt[[i]])
  localpeaks.sumvalues.rnase.zt[i, "Summed_Values"] <- summed_values
}

```

Then we can test for proteins with a significant higher protein amount under the local peaks in the RNase group.

```{r}
signi.local.pa.zt <- data.frame(Zustimmung_local = rep(0, nrow(localpeaks.sumvalues.rnase.zt)))

for (i in 1:nrow(localpeaks.sumvalues.rnase.zt)) {
  if (abs(localpeaks.sumvalues.rnase.zt$Summed_Values[i] - localpeaks.sumvalues.ctrl.zt$Summed_Values[i]) > 7.5)
  {
    signi.local.pa.zt$Zustimmung_local[i] <- 1
  }
}

rownames(signi.local.pa.zt) <- rownames(rnase.zt)

```

#### 7.4.3 protein amount under local peaks shift based on MMS

First we have to sum up the protein amount under all local peaks - for the control group.

```{r}
localpeaks.sumvalues.ctrl.mms <- data.frame(Summed_Values = numeric(length(localpeaks.values.ctrl.mms)))

for (i in seq_along(localpeaks.values.ctrl.mms)) {
  summed_values <- sum(localpeaks.values.ctrl.mms[[i]])
  localpeaks.sumvalues.ctrl.mms[i, "Summed_Values"] <- summed_values
}

```

Protein amount under all local peaks - for the RNase group. 

```{r}
localpeaks.sumvalues.rnase.mms <- data.frame(Summed_Values = numeric(length(localpeaks.values.rnase.mms)))

for (i in seq_along(localpeaks.values.rnase.mms)) {
  summed_values <- sum(localpeaks.values.rnase.mms[[i]])
  localpeaks.sumvalues.rnase.mms[i, "Summed_Values"] <- summed_values
}

```

Then we can test for proteins with a significant higher protein amount under the local peaks in the RNase group.

```{r}
signi.local.pa.mms <- data.frame(Zustimmung_local = rep(0, nrow(localpeaks.sumvalues.rnase.mms)))

for (i in 1:nrow(localpeaks.sumvalues.rnase.mms)) {
  if (abs(localpeaks.sumvalues.rnase.mms$Summed_Values[i] - localpeaks.sumvalues.ctrl.mms$Summed_Values[i]) > 7.5)
  {
    signi.local.pa.mms$Zustimmung_local[i] <- 1
  }
}

rownames(signi.local.pa.mms) <- rownames(rnase.mms)

```


### 7.5 t-test for protein amount shift under global peak

Adding values in 0.25 steps between existing fractions for zt scaling 

```{r}

rnase.zt.1 <- seq(1, ncol(rnase.zt), by = 1)
rnase.zt.0.25 <- seq(1, ncol(rnase.zt), by = 0.25)
rnase.zt_erweitert <- t(apply(rnase.zt, 1, function(y) approx(rnase.zt.1, y, xout =rnase.zt.0.25)$y))
row.names(rnase.zt_erweitert) <- row.names(rnase.zt)
ctrl.zt.1 <- seq(1, ncol(ctrl.zt), by = 1)
ctrl.zt.0.25 <- seq(1, ncol(ctrl.zt), by = 0.25)
ctrl.zt_erweitert <- t(apply(ctrl.zt, 1, function(y) approx(ctrl.zt.1, y, xout = ctrl.zt.0.25)$y))
row.names(ctrl.zt_erweitert) <- row.names(ctrl.zt)

```

y-values of global peak and neighbors for zt

```{r}
globalpeak.neighbors.values.rnase.zt <- apply(rnase.zt_erweitert, 1, function(x) {
peak_indices <- which(x == max(x))
if (peak_indices == 1) {
x[c(peak_indices, peak_indices + 1)]
} else if (peak_indices == ncol(rnase.zt_erweitert)) {
x[c(peak_indices - 1, peak_indices)]
} else {
x[c(peak_indices - 1, peak_indices, peak_indices + 1)]
}
})


globalpeak.neighbors.values.ctrl.zt <- apply(ctrl.zt_erweitert, 1, function(x) {
peak_indices <- which(x == max(x))
if (peak_indices == 1) {
x[c(peak_indices, peak_indices + 1)]
} else if (peak_indices == ncol(ctrl.zt_erweitert)) {
x[c(peak_indices - 1, peak_indices)]
} else {
x[c(peak_indices - 1, peak_indices, peak_indices + 1)]
}
})

```

welch´s t-test andoverlap with parameter A for zt

```{r}
t.test.zt <- numeric(length(globalpeak.neighbors.values.rnase.zt))
for (i in seq_along(globalpeak.neighbors.values.rnase.zt)) {
    test <- t.test(globalpeak.neighbors.values.rnase.zt[[i]], globalpeak.neighbors.values.ctrl.zt[[i]], var.equal = FALSE)
   t.test.zt[[i]] <- c(test$p.value)
  }
t.test.zt <- as.list(t.test.zt)
t.test.zt <- lapply(t.test.zt, function(x)
  if( x <= 0.025) {
    return(1)
  }else{
    return(0)
  }) 
#View(t.test.zt)
signi.global.pa.zt2 <- liste <- apply(signi.global.pa.zt, 1, function(x) as.numeric(x))
View(signi.global.pa.zt2)

overlap.y.shift_t.test.zt <- numeric(length(t.test.zt))
for (i in seq_along(t.test.zt)) {
  if (all(t.test.zt[[i]] == 0) || all(signi.global.pa.zt2[[i]] == 0)) {
    overlap.y.shift_t.test.zt[i] <- 0
  } else {
   overlap.y.shift_t.test.zt[i] <- 1
  }
}


sum(overlap.y.shift_t.test.zt)
sum(unlist(t.test.zt))

```


Adding values in 0.25 steps between existing fractions for mvm scaling 

```{r}

rnase.mvm.1 <- seq(1, ncol(rnase.mvm), by = 1)
rnase.mvm.0.25 <- seq(1, ncol(rnase.mvm), by = 0.25)
rnase.mvm_erweitert <- t(apply(rnase.mvm, 1, function(y) approx(rnase.mvm.1, y, xout =rnase.mvm.0.25)$y))
row.names(rnase.mvm_erweitert) <- row.names(rnase.mvm)
ctrl.mvm.1 <- seq(1, ncol(ctrl.mvm), by = 1)
ctrl.mvm.0.25 <- seq(1, ncol(ctrl.mvm), by = 0.25)
ctrl.mvm_erweitert <- t(apply(ctrl.mvm, 1, function(y) approx(ctrl.mvm.1, y, xout = ctrl.mvm.0.25)$y))
row.names(ctrl.mvm_erweitert) <- row.names(ctrl.mvm)
```

y-values of global peak and neighbors for mvm

```{r}
globalpeak.neighbors.values.rnase.mvm <- apply(rnase.mvm_erweitert, 1, function(x) {
peak_indices <- which(x == max(x))
if (peak_indices == 1) {
x[c(peak_indices, peak_indices + 1)]
} else if (peak_indices == ncol(rnase.mvm_erweitert)) {
x[c(peak_indices - 1, peak_indices)]
} else {
x[c(peak_indices - 1, peak_indices, peak_indices + 1)]
}
})


globalpeak.neighbors.values.ctrl.mvm <- apply(ctrl.mvm_erweitert, 1, function(x) {
peak_indices <- which(x == max(x))
if (peak_indices == 1) {
x[c(peak_indices, peak_indices + 1)]
} else if (peak_indices == ncol(ctrl.mvm_erweitert)) {
x[c(peak_indices - 1, peak_indices)]
} else {
x[c(peak_indices - 1, peak_indices, peak_indices + 1)]
}
})
```

welch´s t-test andoverlap with parameter A for mvm

```{r}
t.test.mvm <- numeric(length(globalpeak.neighbors.values.rnase.mvm))
for (i in seq_along(globalpeak.neighbors.values.rnase.mvm)) {
  
    test <- t.test(globalpeak.neighbors.values.rnase.mvm[[i]], globalpeak.neighbors.values.ctrl.mvm[[i]], var.equal = FALSE)
    t.test.mvm[[i]] <- c(test$p.value)
  }

t.test.mvm <- as.list(t.test.mvm)
t.test.mvm <- lapply(t.test.mvm, function(x)
  if( x <= 0.025) {
    return(1)
  }else{
    return(0)
  })
#View(t.test.mvm)
signi.global.pa.mvm2 <- liste <- apply(signi.global.pa.mvm, 1, function(x) as.numeric(x))
names(signi.global.pa.mvm2) <- 1:length(signi.global.pa.mvm2)
#print(t.test.mvm)
#View(signi.global.pa.mvm2)

overlap.y.shift_t.test.mvm <- numeric(length(t.test.mvm))
for (i in seq_along(t.test.mvm)) {
  if (all(t.test.mvm[[i]] == 0) || all(signi.global.pa.mvm2[[i]] == 0)) {
    overlap.y.shift_t.test.mvm[i] <- 0
  } else {
   overlap.y.shift_t.test.mvm[i] <- 1
  }
}

#sum(overlap.y.shift_t.test.mvm)
#sum(unlist(t.test.mvm))

```


### 7.6. Dataframe with all parameters

Here we combine all parameters in to one data.frame. (For each method)

```{r}
parameters.mvm <- cbind(signi.global.pa.mvm, signi.local.pa.mvm, shift_mvm_named, ShoulderRegion_mvm)

parameters.zt <- cbind(signi.global.pa.zt, signi.local.pa.zt, shift_zt_named, ShoulderRegion_zt)

parameters.mms <- cbind(signi.local.pa.mms, shift_mms_named, ShoulderRegion_mms)

```


## 8. Visualization of Results

With the previously identified parameters we can identify which proteins are RNA-associated.

The following plots visualize our results. (Only considering global shifts, and precipitation):

```{r, warning = False}
shift_named <- cbind(shift_mvm_named, shift_zt_named, shift_mms_named)
plots_RBP <- list()
peak.ctrl.all <- list(globalpeak.ctrl.mvm, globalpeak.ctrl.zt, globalpeak.ctrl.mms)
peak.rnase.all <- list(globalpeak.rnase.mvm, globalpeak.rnase.zt, globalpeak.rnase.mms)

library("ggplot2")

for (x in 1:3){

  col <- c("skyblue2", "darkseagreen3","tomato1", "lightsteelblue4" )
  vjust <- c(-0.5, 1, -0.5, -0.5)
  labels <- c("right shift", "no shift", "precipitated", "left shift")
  
  title <- c("Shifttypes Mean Value Method", "Shifttypes z-Transformation", "Shifttypes Min-Max-Scaling")
  
  peak.ctrl <- peak.ctrl.all[[x]]
  peak.rnase <- peak.rnase.all[[x]]
  
  peaks <- data.frame(peak.ctrl, peak.rnase, shift_named[,x])
  number.of.clusters <- data.frame(value = shift_named[,x])
  peaks$cluster <- factor(shift_named[,x])
  
  
  dot.plot <- ggplot(peaks, aes(peak.ctrl,peak.rnase)) + 
    geom_point(aes(colour = shift_named[,x]), 
               shape = 19, 
               alpha = 0.5, size = 1.5, 
               position = position_jitter(width = 0.2, height = 0.2))+
    labs(x = "Fraction of Control Peak", 
         y = "Fraction of RNase Peak", 
         title = title[x])+
    coord_equal()+
    scale_colour_manual(values = col,labels = labels, name = "shifttypes")+
    theme_light()
  
  
  bar.plot <- ggplot(number.of.clusters, aes(factor(value)))+
    geom_bar(fill = col, width = 0.7)+
    theme_minimal()+
    theme(axis.text.x = element_blank(), 
          axis.text.y = element_blank(),
          axis.title.x = element_blank(), 
          axis.title.y = element_blank(),
          panel.grid = element_blank(),
          panel.border = element_rect(color = "grey", fill = NA),
          panel.background = element_rect(fill = "white", colour = NA))+
    geom_text(stat = 'count', 
              aes(label = after_stat(count)), 
              vjust = vjust, 
              size = 2.7)
  
  
  plots_RBP[[x]] <- dot.plot + annotation_custom(grob = ggplotGrob(bar.plot), 
                      xmin = 15, 
                      xmax = 26.75, 
                      ymin = -1, 
                      ymax = 8)
  print(plots_RBP[[x]])
}
```
This beautiful visualization makes the plot ready for our report.

```{r}
print(plots_RBP[[1]] + labs(subtitle = paste("Figure 5: Categorization into shifting behaviour based on global shift.")) + theme(panel.background = element_rect(fill = "gray98")) + theme(plot.background = element_rect(fill = "gray97")) + theme(legend.background = element_rect(fill = "gray97")) + theme(legend.key = element_rect(fill = "gray98")))
```



This barplot shows us how many proteins are RNA associated according to how many parameters:

```{r}
library(ggplot2)
library(ggpubr)


parameters.all <- list(parameters.mvm, parameters.zt, parameters.mms) #parameters.mms fehlt
plot.parameters <- list()

for (z in 1:3){
  parameters <- parameters.all[[z]]
  
  if (z == 3){
    g <- 2
  }else{g <- 3}
  
  for (y in 1:dim(parameters)[1]){
    if (parameters[y,g] == "no shift"){
      parameters[y,g] <- 0
    } else{parameters[y,g] <- 1}
  }

  parameters.m <- as.matrix(parameters)
  sum_parameters <- apply(parameters.m, 1, function(x){
    sum(as.numeric(x))})
  
  df <- as.data.frame(sum_parameters)
  title <- c("How many parameters support the proteins? MVM", 
             "How many parameters support the proteins? z-Transformation", 
             "How many parameters support the proteins? MMS")
  
  plot.parameters[[z]]<- ggplot(df, aes(factor(sum_parameters)))+
    geom_bar(colour = "darkblue", fill="skyblue")+
    geom_text(stat = 'count', 
              aes(label = after_stat(count)), 
              vjust = -0.25)+
    labs(x = "number of parameters pro shift", 
         y = "number of proteins", 
         title = title[z])
  
  print(plot.parameters[[z]])
}

```
This barplot shows us how many proteins are RNA associated according to how many parameters. Additionally it shows which parameters were present. 

```{r}
library(ggplot2)

parameters.all <- list(parameters.mvm, parameters.zt, parameters.mms)
plot.parameters.detail <- list()

for (z in 1:3){
  parameters <- parameters.all[[z]]
  
  if(z == 3){
    g <- 2
  }else{g <- 3}
  for (y in 1:dim(parameters)[1]){
    if (parameters[y,g] == "no shift"){
      parameters[y,g] <- 0
    } else{parameters[y,g] <- 1}
  }
  parameters.m <- as.matrix(parameters)
  sum_parameters <- apply(parameters.m, 1, function(x){
    sum(as.numeric(x))})
  
  df <- as.data.frame(sum_parameters)
  title <- c("Protein spilt by number of Parameters", 
             "Protein spilt by number of Parameters - zTransformation",
             "Protein spilt by number of Parameters - MMS")

  if(z == 3){
    c <- c(0,1,2,3)
  }else{c<- c(0,1,2,3,4)}
  
  if(z == 3){
    d <- 0
  }
  else {d <- 1}
    
  if (z != 3){
    df.glob <- as.data.frame(parameters[,d])
    df.glob.sum <- as.data.frame(c)
    for (x in 0:4){
      df.glob.sum[x+1,2] <- sum(df.glob[which(sum_parameters == x),])}}
  
  df.loc <- as.data.frame(parameters[,d+1])
  df.loc.sum <- as.data.frame(c)
  for (x in 0:(d+3)){
    df.loc.sum[x+1,2] <- 
      sum(as.numeric(df.loc[which(sum_parameters == x),]))}
  
  df.shift <- as.data.frame(parameters[,d+2])
  df.shift.sum <- as.data.frame(c)
  for (x in 0:(d+3)){
    df.shift.sum[x+1,2] <- 
      sum(as.numeric(df.shift[which(sum_parameters == x),]))} 
  
  df.shoulder <- as.data.frame(parameters[,d+3])
  df.shoulder.sum <- as.data.frame(c)
  for (x in 0:(d+3)){
    df.shoulder.sum[x+1,2] <- 
      sum(df.shoulder[which(sum_parameters == x),])}
  
  df.sum <- as.data.frame(sum_parameters)
  df.sum.sum <- as.data.frame(c)
  for (x in 0:(d+3)){
    df.sum.sum[x+1,2] <- sum(sum_parameters == x)}
  
  if (z != 3){
    df2 <- data.frame(category = c(df.glob.sum[,1], df.loc.sum[,1], 
                                   df.shift.sum[,1], df.shoulder.sum[,1], 
                                   df.sum.sum[,1]), 
                      value = c(df.glob.sum[,2], df.loc.sum[,2], 
                                df.shift.sum[,2], df.shoulder.sum[,2], 
                                df.sum.sum[,2]),
                      Parameters = c(rep(c("Global", "Local", "Shifts", 
                                           "Shoulderregion", "Total"), 
                                         each = 5)))
  }else{
    df2 <- data.frame(category = c(df.loc.sum[,1], df.shift.sum[,1], 
                                   df.shoulder.sum[,1],df.sum.sum[,1]), 
                      value = c(df.loc.sum[,2], df.shift.sum[,2], 
                                df.shoulder.sum[,2], df.sum.sum[,2]),
                      Parameters = c(rep(c("Local", "Shift", "Shoulderregion", 
                                           "Total"), each = 4)))
  }
  
  if(z == 3){
    colour <- c("coral3", "lightsteelblue4","paleturquoise3", "lightsteelblue2" )
  }else{colour <- c("coral3", "lightsteelblue4", "darkseagreen3", "paleturquoise3", "lightsteelblue2" )}
  
  plot.parameters.detail[[z]] <- 
    ggplot(df2, aes(x = category, y = value, fill = Parameters))+
    geom_bar(stat = "identity", position = position_dodge(width = 0.9))+
    theme_bw()+
    geom_text(aes(label = value), 
              vjust = -0.5, 
              position = position_dodge(width = 0.9), 
              size = 2)+
    labs(x = "Number of Parameters", 
         y = "Number of Proteins", 
         title = title[[z]])+
    scale_fill_manual(values = colour)
  
  print(plot.parameters.detail[[z]])
}
```

This makes it ready for our report.

```{r}
print(plot.parameters.detail[[1]] + labs(subtitle = 
paste("Figure 5: The number of Proteins for each Parameter depending on the occuring 
                Parameter amount is depicted.")) + theme(panel.background = element_rect(fill = "gray98")) + theme(plot.background = element_rect(fill = "gray97")) + theme(legend.background = element_rect(fill = "gray97")) + theme(legend.key = element_rect(fill = "gray98")))
```




## 9. Kmeans clustering

Here we cluster the peaks after different parameters. This helps to visualize the parameters from before. 

Here we cluster the Proteins depending on the fractions in which the peaks are. 
First we test the optimal number of clusters

```{r}
df.peaks <- data.frame(cbind(globalpeak.ctrl.mvm, globalpeak.rnase.mvm, globalpeak.ctrl.zt, globalpeak.rnase.zt, globalpeak.ctrl.mms, globalpeak.rnase.mms))

wss <- sapply(1:5, function(x){
  kmeans(df.peaks, centers = x, nstart = 20)$tot.withinss
})


library("ggplot2")
wss.df <- data.frame(values = wss)
ggplot(wss.df, aes(x = 1:length(wss), y = values))+
  geom_line(col = "mediumvioletred", lwd = 0.75)+
  geom_point(col = "midnightblue")+
  theme_bw()+
  labs(x = "Number of clusters", y = "number of assigned proteins")+
  theme(panel.border = element_rect(color="grey", fill = NA))

```

If we follow the results of the elbow method, the optimal number of clusters would be 2. But this would not lead to any useful results. So we force kmeans to create 4 clusters...

```{r, warning = False}
library("ggpubr")
library("factoextra")
library("ggplot2")
df.peaks <- data.frame(cbind(globalpeak.ctrl.mvm, globalpeak.rnase.mvm, globalpeak.ctrl.zt, globalpeak.rnase.zt, globalpeak.ctrl.mms, globalpeak.rnase.mms))

plot.cluster.fractions <- list()

title <- c("Clusters of Peaks calculated after MVM","Clusters of Peaks calculated after z-Transformation", "Clusters of Peaks calculated after MMS")

res.km <- list() 

for (x in 1:3){
  
  df <- df.peaks[,(2*x -1):(2*x)]
  
  set.seed(666)
  res.km[[x]] <- kmeans(scale(df[, -5]), 4, nstart = 25)
  

  g <- fviz_cluster(res.km[[x]], data = df,
                  geom = "point",
                  xlab = "Global Control Peaks",
                  ylab = "Global RNase Peaks",
                  main = title[x],
                  ggtheme = theme_bw(),
                  palette = c("lightsteelblue2", "darkseagreen3","tomato1", "lightsteelblue4" ))
                  
plot.cluster.fractions[[x]] <- g + theme(axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks = element_blank()) 

print(plot.cluster.fractions[[x]])
}

```


We select the cluster at the bottom right to be RNA-associated. For MVM this would be cluster 2, for z-transformation cluster 3 and for MMS cluster 4 (first three rows of code below should be adapted if this is not the case).

```{r}
cluster.nr.mvm <- 2
cluster.nr.zt <- 3
cluster.nr.mms <- 4

cluster.nr <- c(cluster.nr.mvm, cluster.nr.zt, cluster.nr.mms)
shift.kmeans <- list(as.data.frame(rep(NA, length(res.km[[1]]$cluster))),
                     as.data.frame(rep(NA, length(res.km[[1]]$cluster))),
                     as.data.frame(rep(NA, length(res.km[[1]]$cluster))))

for(z in 1:3){
  for (x in 1:length(res.km[[z]]$cluster)){
    if ((res.km[[z]]$cluster)[x] == cluster.nr[z]){
      shift.kmeans[[z]][x,1] <- 1
    }else{shift.kmeans[[z]][x,1] <- 0}
  }}

colnames <- c("MVM", "zt", "MMS")

for(y in 1:3){
  rownames(shift.kmeans[[y]]) = rownames(parameters.mms)
  colnames(shift.kmeans[[y]]) = colnames[y]
  }

#sum(shift.kmeans[[1]][,1] == 1)
#sum(shift.kmeans[[2]][,1] == 1)
#sum(shift.kmeans[[3]][,1] == 1)
```
With this method we could identify 160 RNA-associated Proteins for MVM, 155 for z-transformation and 159 for Min-Max-Scaling



## 10. Regression analysis 

Here we create data frames for the regression analysis.

```{r}
parameters.all <- list(parameters.mvm, parameters.zt, parameters.mms)

shift.vector.all <- list()

for (z in 1:3){
  parameters <- parameters.all[[z]]
  
  if(z == 3){
    g <- 2
  }else{g <- 3}
  for (y in 1:dim(parameters)[1]){
    if (parameters[y,g] == "no shift"){
      parameters[y,g] <- 0
    } else{parameters[y,g] <- 1}
  }
  parameters.m <- as.matrix(parameters)
  sum_parameters <- apply(parameters.m, 1, function(x){
    sum(as.numeric(x))})

  if(z == 3){
    c <- c(0,1,2,3)
  }else{c<- c(0,1,2,3,4)}
  
  if(z == 3){
    d <- 0
  }
  else {d <- 1}
  
  df.shift <- as.data.frame(parameters[,d+2])
  df.shift.sum <- as.data.frame(c)
  for (x in 0:(d+3)){
    df.shift.sum[x+1,2] <- 
      sum(as.numeric(df.shift[which(sum_parameters == x),]))} 
  
    vector <- c()
  for (x in 1:3074){
    if(sum_parameters[x] == 2 || sum_parameters[x] == 3 || 
       sum_parameters[x] == 4 || as.numeric(df.shift[x,1]) == 1){
      vector[x] <- 1
    }else{vector[x] <- 0}}

shift.vector.all[[z]] <- vector
}

shift.vector.mvm <- shift.vector.all[[1]]
shift.vector.zt <- shift.vector.all[[2]]
shift.vector.mms <- shift.vector.all[[3]]  

```
Here they are converted to data frames.

```{r}
shift_mvm <- as.data.frame(shift.vector.mvm)
shift_zt <- as.data.frame(shift.vector.zt)
shift_mms <- as.data.frame(shift.vector.mms)
```


### 10.1 Regression analysis MVM 

#### 10.1.1 Regression analysis based on the shift amount

The two parameters for the regression analysis are the global shift amount and the correlation between the Ctrl and RNase dataset. The global shift amount is already calculated and saved as dataframe in absolute numbers under *shift.amount*. First we determine the correlation.

```{r}
shift.amount = data.frame(shift_mvm_global)

correlation.mvm <-as.data.frame( sapply(1:nrow(ctrl.mvm), function(i) cor(ctrl.mvm[i, ], rnase.mvm[i, ])))
rownames(correlation.mvm) <- rownames(rnase.mvm)
```

Afterwards we perform the linear Regression to predict the global shift based on the correlation. Proteins with a right shift have an entry of 1, those with a left shift of -1 and the no shifters of 0.

```{r}
train_mvm_2 <- data.frame(Korrelation_2 = correlation.mvm[1:2500, ], Shift_2 = shift.amount[1:2500, ])

model_mvm_all_2 <- lm(Shift_2 ~ Korrelation_2, data = train_mvm_2)

test_mvm_2 <- data.frame(Korrelation_2 = correlation.mvm[2501:3074, ])

predictions_mvm_2 <- as.data.frame(predict(model_mvm_all_2, newdata = test_mvm_2))

predictions_mvm_rdeep <- matrix(0, nrow = nrow(predictions_mvm_2), ncol = ncol(predictions_mvm_2))

for(i in 1:nrow(predictions_mvm_2)) {
  for(j in 1:ncol(predictions_mvm_2)){
    if(predictions_mvm_2[i,j] > 2) {
      predictions_mvm_rdeep[i,j] <- 1 
    }  else if(predictions_mvm_2[i,j] < (-2)) {
      predictions_mvm_rdeep[i,j] <- (-1)
    } else {predictions_mvm_rdeep[i,j] <- 0
    }
  }
}

rownames(predictions_mvm_rdeep) <- rownames(rnase.mvm[2501:3074, ])

print(summary(model_mvm_all_2))
# View(predictions_mvm_rdeep)
```

Last but not least, the regression model is shown graphically.

```{r, fig.show="hold", out.width="50%"}
x <- train_mvm_2$Korrelation_2
y <- train_mvm_2$Shift_2


plot(x, y, main = "Regression Analysis", xlab = "Correlation - Ctrl and RNase", ylab = "Shift in Fraction", xlim = c(min(x), max(x)), ylim = c(min(y), max(y)), pch = 16, cex = 0.9, cex.main = 0.97, cex.lab = 0.9, col = "darkgrey")


abline(model_mvm_all_2, col = "red", lwd = 2)

abline(h = 2.5, col = "green4", lwd = 2)
abline(h = - 2.5, col = "green4", lwd = 2)


test_x <- test_mvm_2$Korrelation_2
predicted_y <- predict(model_mvm_all_2, newdata = test_mvm_2)


points(test_x, predicted_y, col = "lightblue", pch = 16, cex = 0.9)


legend("topleft", legend = c("Trained Data", "Predicted Data", "Regression Curve", "Threshold"),col = c("darkgrey", "lightblue", "red", "green4"), pch = c(16, 16, NA, NA), lty = c(NA, NA, 1, 1), cex = 0.8)



shift.amount.plot = abs(data.frame(shift_mvm_global))

train_mvm_plot <- data.frame(Korrelation_plot = correlation.mvm[1:2500, ], Shift_plot = shift.amount.plot[1:2500, ])

model_mvm_all_plot <- lm(Shift_plot ~ Korrelation_plot, data = train_mvm_plot)

test_mvm_plot <- data.frame(Korrelation_plot = correlation.mvm[2501:3074, ])

predictions_mvm_plot <- as.data.frame(predict(model_mvm_all_plot, newdata = test_mvm_plot))
rownames(predictions_mvm_plot) <- rownames(rnase.mvm[2501:3074, ])

px <- train_mvm_plot$Korrelation_plot
py <- train_mvm_plot$Shift_plot


plot(px, py, main = "Regression Analysis", xlab = "Correlation - Ctrl and RNase", ylab = "Shift in Fraction", xlim = c(min(px), max(px)), ylim = c(min(py), max(py)), pch = 16, cex = 0.9, cex.main = 0.97, cex.lab = 0.9, col = "darkgrey")


abline(model_mvm_all_plot, col = "red", lwd = 2)

abline(h = 2.5, col = "green4", lwd = 2)


test_px <- test_mvm_plot$Korrelation_plot
predicted_py <- predict(model_mvm_all_plot, newdata = test_mvm_plot)


points(test_px, predicted_py, col = "lightblue", pch = 16, cex = 0.9)


legend("topright", legend = c("Trained Data", "Predicted Data", "Regression Curve", "Threshold"),col = c("darkgrey", "lightblue", "red", "green4"), pch = c(16, 16, NA, NA), lty = c(NA, NA, 1, 1), cex = 0.8)
```

#### 10.1.2 Regression analysis using all parameters 

```{r}
train_mvm <- data.frame(Korrelation = correlation.mvm[1:2500, ], Shift = shift_mvm[1:2500, ])

model_mvm_all <- lm(Shift ~ Korrelation, data = train_mvm)

test_mvm <- data.frame(Korrelation = correlation.mvm[2501:3074, ])

predictions_mvm <- as.data.frame(predict(model_mvm_all, newdata = test_mvm))
rounded_predictions_mvm_all <- round(predictions_mvm)
rownames(rounded_predictions_mvm_all) <- rownames(rnase.mvm[2501:3074, ])


print(summary(model_mvm_all))

#print(rounded_predictions_mvm_all)

```

### 10.2 Regression analysis z-Transformation

#### 10.2.1 Regression analysis based on fraction shift

The two parameters for the regression analysis are the global shift amount and the correlation between the Ctrl and RNase dataset. The global shift amount is already calculated and saved as dataframe in absolute numbers under *shift.amount*. First we determine the correlation.

```{r}
shift.amount = data.frame(shift_mvm_global)

correlation.zt <-as.data.frame(sapply(1:nrow(ctrl.zt), function(i) cor(as.numeric(ctrl.zt[i, ]), as.numeric(rnase.zt[i, ]))))
rownames(correlation.zt) <- rownames(rnase.zt)
```

Afterwards we perform the linear Regression to predict the global shift based on the correlation. Proteins with a right shift have an entry of 1, those with a left shift of -1 and the no shifters of 0.

```{r}
train_zt_2 <- data.frame(Korrelation_2 = correlation.zt[1:2500, ], Shift_2 = shift.amount[1:2500, ])

model_zt_all_2 <- lm(Shift_2 ~ Korrelation_2, data = train_zt_2)

test_zt_2 <- data.frame(Korrelation_2 = correlation.zt[2501:3074, ])

predictions_zt_2 <- as.data.frame(predict(model_zt_all_2, newdata = test_zt_2))

predictions_zt_rdeep <- matrix(0, nrow = nrow(predictions_zt_2), ncol = ncol(predictions_zt_2))

for(i in 1:nrow(predictions_zt_2)) {
  for(j in 1:ncol(predictions_zt_2)){
    if(predictions_zt_2[i,j] > 2) {
      predictions_zt_rdeep[i,j] <- 1 
    }  else if(predictions_zt_2[i,j] < (-2)) {
      predictions_zt_rdeep[i,j] <- (-1)
    } else {predictions_zt_rdeep[i,j] <- 0
    }
  }
}

rownames(predictions_zt_rdeep) <- rownames(rnase.zt[2501:3074, ])

# print(summary(model_zt_all_2))
# View(predictions_zt_rdeep)
```

Last but not least, the regression model is shown graphically.

```{r, fig.show="hold", out.width="50%"}
x <- train_zt_2$Korrelation_2
y <- train_zt_2$Shift_2


plot(x, y, main = "Regression Analysis", xlab = "Correlation - Ctrl and RNase", ylab = "Shift in Fraction", xlim = c(min(x), max(x)), ylim = c(min(y), max(y)), pch = 16, cex = 0.9, cex.main = 0.97, cex.lab = 0.9, col = "darkgrey")


abline(model_zt_all_2, col = "red", lwd = 2)

abline(h = 2.5, col = "green4", lwd = 2)
abline(h = - 2.5, col = "green4", lwd = 2)


test_x <- test_zt_2$Korrelation_2
predicted_y <- predict(model_zt_all_2, newdata = test_zt_2)


points(test_x, predicted_y, col = "lightblue", pch = 16, cex = 0.9)


legend("topleft", legend = c("Trained Data", "Predicted Data", "Regression Curve", "Threshold"),col = c("darkgrey", "lightblue", "red", "green4"), pch = c(16, 16, NA, NA), lty = c(NA, NA, 1, 1), cex = 0.8)



shift.amount.plot = abs(data.frame(shift_zt_global))

train_zt_plot <- data.frame(Korrelation_plot = correlation.zt[1:2500, ], Shift_plot = shift.amount.plot[1:2500, ])

model_zt_all_plot <- lm(Shift_plot ~ Korrelation_plot, data = train_zt_plot)

test_zt_plot <- data.frame(Korrelation_plot = correlation.zt[2501:3074, ])

predictions_zt_plot <- as.data.frame(predict(model_zt_all_plot, newdata = test_zt_plot))
rownames(predictions_zt_plot) <- rownames(rnase.zt[2501:3074, ])

px <- train_zt_plot$Korrelation_plot
py <- train_zt_plot$Shift_plot


plot(px, py, main = "Regression Analysis", xlab = "Correlation - Ctrl and RNase", ylab = "Shift in Fraction", xlim = c(min(px), max(px)), ylim = c(min(py), max(py)), pch = 16, cex = 0.9, cex.main = 0.97, cex.lab = 0.9, col = "darkgrey")


abline(model_zt_all_plot, col = "red", lwd = 2)

abline(h = 2.5, col = "green4", lwd = 2)


test_px <- test_zt_plot$Korrelation_plot
predicted_py <- predict(model_zt_all_plot, newdata = test_zt_plot)


points(test_px, predicted_py, col = "lightblue", pch = 16, cex = 0.9)


legend("topright", legend = c("Trained Data", "Predicted Data", "Regression Curve", "Threshold"),col = c("darkgrey", "lightblue", "red", "green4"), pch = c(16, 16, NA, NA), lty = c(NA, NA, 1, 1), cex = 0.8)
```

#### 10.2.2 Regression analysis using all parameters 

```{r}
train_zt <- data.frame(Korrelation_zt = correlation.zt[1:2500, ], Shift = shift_zt[1:2500, ])

model_zt_all <- lm(Shift ~ Korrelation_zt, data = train_zt)

test_zt <- data.frame(Korrelation_zt = correlation.zt[2501:3074, ])

predictions_zt <- as.data.frame(predict(model_zt_all, newdata = test_zt))
rounded_predictions_zt_all <- round(predictions_zt)
rownames(rounded_predictions_zt_all) <- rownames(rnase.zt[2501:3074, ])

print(summary(model_zt_all)) 
#print(rounded_predictions_zt_all)
```


### 10.3 Regression analysis MMS 

#### 10.3.1 Regression analysis based on the shift amount

The two parameters for the regression analysis are the global shift amount and the correlation between the Ctrl and RNase dataset. The global shift amount is already calculated and saved as dataframe in absolute numbers under *shift.amount*. First we determine the correlation.
```{r}
shift.amount = data.frame(shift_mms_global)

correlation.mms <-as.data.frame( sapply(1:nrow(ctrl.mms), function(i) cor(ctrl.mms[i, ], rnase.mms[i, ])))
rownames(correlation.mms) <- rownames(rnase.mms)
```

Afterwards we perform the linear Regression to predict the global shift based on the correlation. Proteins with a right shift have an entry of 1, those with a left shift of -1 and the no shifters of 0.
```{r}
train_mms_2 <- data.frame(Korrelation_2 = correlation.mms[1:2500, ], Shift_2 = shift.amount[1:2500, ])

model_mms_all_2 <- lm(Shift_2 ~ Korrelation_2, data = train_mms_2)

test_mms_2 <- data.frame(Korrelation_2 = correlation.mms[2501:3074, ])

predictions_mms_2 <- as.data.frame(predict(model_mms_all_2, newdata = test_mms_2))

predictions_mms_rdeep <- matrix(0, nrow = nrow(predictions_mms_2), ncol = ncol(predictions_mms_2))

for(i in 1:nrow(predictions_mms_2)) {
  for(j in 1:ncol(predictions_mms_2)){
    if(predictions_mms_2[i,j] > 2) {
      predictions_mms_rdeep[i,j] <- 1 
    }  else if(predictions_mms_2[i,j] < (-2)) {
      predictions_mms_rdeep[i,j] <- (-1)
    } else {predictions_mms_rdeep[i,j] <- 0
    }
  }
}

rownames(predictions_mms_rdeep) <- rownames(rnase.mms[2501:3074, ])

# print(summary(model_mms_all_2))
# View(predictions_mms_rdeep)
```

Last but not least, the regression model is shown graphically.

```{r, fig.show="hold", out.width="50%"}
x <- train_mms_2$Korrelation_2
y <- train_mms_2$Shift_2


plot(x, y, main = "Regression Analysis", xlab = "Correlation - Ctrl and RNase", ylab = "Shift in Fraction", xlim = c(min(x), max(x)), ylim = c(min(y), max(y)), pch = 16, cex = 0.9, cex.main = 0.97, cex.lab = 0.9, col = "darkgrey")


abline(model_mms_all_2, col = "red", lwd = 2)

abline(h = 2.5, col = "green4", lwd = 2)
abline(h = - 2.5, col = "green4", lwd = 2)


test_x <- test_mms_2$Korrelation_2
predicted_y <- predict(model_mms_all_2, newdata = test_mms_2)


points(test_x, predicted_y, col = "lightblue", pch = 16, cex = 0.9)


legend("topleft", legend = c("Trained Data", "Predicted Data", "Regression Curve", "Threshold"),col = c("darkgrey", "lightblue", "red", "green4"), pch = c(16, 16, NA, NA), lty = c(NA, NA, 1, 1), cex = 0.8)



shift.amount.plot = abs(data.frame(shift_mms_global))

train_mms_plot <- data.frame(Korrelation_plot = correlation.mvm[1:2500, ], Shift_plot = shift.amount.plot[1:2500, ])

model_mms_all_plot <- lm(Shift_plot ~ Korrelation_plot, data = train_mms_plot)

test_mms_plot <- data.frame(Korrelation_plot = correlation.mms[2501:3074, ])

predictions_mms_plot <- as.data.frame(predict(model_mms_all_plot, newdata = test_mms_plot))
rownames(predictions_mms_plot) <- rownames(rnase.mms[2501:3074, ])

px <- train_mms_plot$Korrelation_plot
py <- train_mms_plot$Shift_plot


plot(px, py, main = "Regression Analysis", xlab = "Correlation - Ctrl and RNase", ylab = "Shift in Fraction", xlim = c(min(px), max(px)), ylim = c(min(py), max(py)), pch = 16, cex = 0.9, cex.main = 0.97, cex.lab = 0.9, col = "darkgrey")


abline(model_mms_all_plot, col = "red", lwd = 2)

abline(h = 2.5, col = "green4", lwd = 2)


test_px <- test_mms_plot$Korrelation_plot
predicted_py <- predict(model_mms_all_plot, newdata = test_mms_plot)


points(test_px, predicted_py, col = "lightblue", pch = 16, cex = 0.9)


legend("topright", legend = c("Trained Data", "Predicted Data", "Regression Curve", "Threshold"),col = c("darkgrey", "lightblue", "red", "green4"), pch = c(16, 16, NA, NA), lty = c(NA, NA, 1, 1), cex = 0.8)
```

#### 10.3.2 Regression analysis using all parameters 

```{r}
train_mms <- data.frame(Korrelation = correlation.mms[1:2500, ], Shift = shift_mms[1:2500, ])

model_mms_all <- lm(Shift ~ Korrelation, data = train_mms)

test_mms <- data.frame(Korrelation = correlation.mms[2501:3074, ])

predictions_mms <- as.data.frame(predict(model_mms_all, newdata = test_mms))
rounded_predictions_mms_all <- round(predictions_mms)
rownames(rounded_predictions_mms_all) <- rownames(rnase.mms[2501:3074, ])


print(summary(model_mms_all))
#print(rounded_predictions_mms_all)
```

### 10.4. Comparison of trained data based on global shift amount with RDeep

#### 10.4.1. Data preparation

Regression based on global shift amount.

```{r}
predictions_mms_rdeep_shift <- matrix(0, nrow = nrow(predictions_mms_plot), ncol = ncol(predictions_mms_plot))

for(i in 1:nrow(predictions_mms_plot)) {
  for(j in 1:ncol(predictions_mms_plot)){
    if(predictions_mms_plot[i,j] > 2) {
      predictions_mms_rdeep_shift[i,j] <- 1 
    } else if (predictions_mms_plot[i,j] < 2) {
      predictions_mms_rdeep_shift[i,j] <- 0
    } 
  }
}

rownames(predictions_mms_rdeep_shift) <- rownames(rnase.mms[2501:3074, ])
# predictions_mms_rdeep_shift


predictions_zt_rdeep_shift <- matrix(0, nrow = nrow(predictions_zt_plot), ncol = ncol(predictions_zt_plot))

for(i in 1:nrow(predictions_zt_plot)) {
  for(j in 1:ncol(predictions_zt_plot)){
    if(predictions_zt_plot[i,j] > 2) {
      predictions_zt_rdeep_shift[i,j] <- 1 
    } else if (predictions_zt_plot[i,j] < 2) {
      predictions_zt_rdeep_shift[i,j] <- 0
    } 
  }
}

rownames(predictions_zt_rdeep_shift) <- rownames(rnase.zt[2501:3074, ])

predictions_mvm_rdeep_shift <- matrix(0, nrow = nrow(predictions_mvm_plot), ncol = ncol(predictions_mvm_plot))

for(i in 1:nrow(predictions_mvm_plot)) {
  for(j in 1:ncol(predictions_mvm_plot)){
    if(predictions_mvm_plot[i,j] > 2) {
      predictions_mvm_rdeep_shift[i,j] <- 1 
    } else if (predictions_mvm_plot[i,j] < 2) {
      predictions_mvm_rdeep_shift[i,j] <- 0
    } 
  }
}

rownames(predictions_mvm_rdeep_shift) <- rownames(rnase.mvm[2501:3074, ])
```

Preparing the results for comparison. 

```{r}
names.rdp.mvm.regression <- rownames(predictions_mvm_rdeep_shift)[which(predictions_mvm_rdeep_shift == 1)]
names.rdp.zt.regression <- rownames(predictions_zt_rdeep_shift)[which(predictions_zt_rdeep_shift == 1)]
names.rdp.mms.regression <- rownames(predictions_mms_rdeep_shift)[which(predictions_mms_rdeep_shift == 1)]

names.rdp.regression <- list(names.rdp.mvm.regression, names.rdp.zt.regression, names.rdp.mms.regression)
number.observed.RBPs.regression <- c(length(names.rdp.mvm.regression), length(names.rdp.zt.regression), length(names.rdp.mms.regression))


names.nrdp.mvm.regression <- rownames(predictions_mvm_rdeep_shift)[which(predictions_mvm_rdeep_shift == 0)]
names.nrdp.zt.regression <- rownames(predictions_zt_rdeep_shift)[which(predictions_zt_rdeep_shift == 0)]
names.nrdp.mms.regression <- rownames(predictions_mms_rdeep_shift)[which(predictions_mms_rdeep_shift == 0)]

names.nrdp.regression <- list(names.nrdp.mvm.regression, names.nrdp.zt.regression, names.nrdp.mms.regression)
number.observed.nonRBPs.regression <- c(length(names.nrdp.mvm.regression), length(names.nrdp.zt.regression), length(names.nrdp.mms.regression))
```

Here we load the Rdeep data we want to compare our results to.

```{r}
rdeep <- read.csv('archive/Data for comparison/Rajagopal_R-DeeP.csv', header=TRUE, sep = ";")
#View(rdeep)

rdeep.unknown <- read.csv('archive/Data for comparison/nonRdeep2.0.csv', header=FALSE, sep = ";")
#View(rdeep.unknown)
```


#### 10.4.2 True Positives - regression

Check how many of our proteins really are RNA-dependent:

```{r}
# number.observed.RBPs.regression
```

Number of correctly assigned (true positives) RBPs with parameters

```{r}
true.positives.regression.shift <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.rdp.regression[[z]]) {
    if (i %in% rdeep[,1]) {
      counter <- counter + 1
    }
  }
  true.positives.regression.shift[z] <- counter
}

```


#### 10.4.3 False positives - regression

Number of wrongly assigned (false positives) RBPs with parameters

```{r}

false.positives.regression.shift <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.rdp.regression[[z]]) {
    if (!(i %in% rdeep[,1]) & (!(i %in% rdeep.unknown[,1]))) {
      counter <- counter + 1
    }
  }
  false.positives.regression.shift[z] <- counter
}

```

#### 10.4.4 True negatives - regression

```{r}
#number.observed.nonRBPs.regression
```

Number of correctly assigned non-RBPs (true negatives) with parameters

```{r}


true.negatives.regression.shift <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.nrdp.regression[[z]]) {
    if (!(i %in% rdeep[,1]) & (!(i %in% rdeep.unknown[,1]))) {
      counter <- counter + 1
    }
  }
  true.negatives.regression.shift[z] <- counter
}

```


#### 10.4.5 False negatives - regression

Number of wrongly assigned non-RBPs (true negatives) with parameters

```{r}
false.negatives.regression.shift <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.nrdp.regression[[z]]) {
    if (i %in% rdeep[,1]) {
      counter <- counter + 1
    }
  }
  false.negatives.regression.shift[z] <- counter
}
# false.negatives.regression.shift
```

#### 10.4.6 false-negative-rate (FNR) - regression

FNR = FN/(FN + TP)

```{r}
fnr.regression.shift <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  fnr.regression.shift[x] <- false.negatives.regression.shift[x]/(false.negatives.regression.shift[x] + true.positives.regression.shift[x])
}
fnr.regression.shift
```



#### 10.4.7 false-positive-rate (FPR) - regression

FPR = FP/(FP + TN)

```{r}
fpr.regression.shift <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  fpr.regression.shift[x] <- false.positives.regression.shift[x]/(false.positives.regression.shift[x]+true.negatives.regression.shift[x])
}
fpr.regression.shift
```



#### 10.4.8 Precision - regression

precision = TP/(TP + FP)

```{r}
precision.regression.shift <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  precision.regression.shift[x] <- true.positives.regression.shift[x]/(true.positives.regression.shift[x] + false.positives.regression.shift[x])
}
precision.regression.shift
```


## 11. Comparison with RDeep

Since the data we want to compare our results to was already loaded in 10.4.1. we don't have to do this again here.

Here we prepare our parameters, kmeans and global shift results, for comparison. 

```{r}
# the proteins identified as RNA-dependent by our four parameters:
comp.mvm.parameters <- shift_mvm
comp.zt.parameters <- shift_zt
comp.mms.parameters <- shift_mms

rownames(comp.mvm.parameters) = rownames(parameters.mms)
rownames(comp.zt.parameters) = rownames(parameters.mms)
rownames(comp.mms.parameters) = rownames(parameters.mms)

names.rdp.mvm.parameters <- rownames(comp.mvm.parameters)[which(comp.mvm.parameters == 1)]
names.rdp.zt.parameters <- rownames(comp.zt.parameters)[which(comp.zt.parameters == 1)]
names.rdp.mms.parameters <- rownames(comp.mms.parameters)[which(comp.mms.parameters == 1)]

names.rdp.parameters <- list(names.rdp.mvm.parameters, names.rdp.zt.parameters, names.rdp.mms.parameters)

number.observed.RBPs.parameters <- c(length(names.rdp.mvm.parameters), length(names.rdp.zt.parameters), length(names.rdp.mms.parameters))

# the proteins identified as non-RNA-dependent by our four parameters:
names.nrdp.mvm.parameters <- rownames(comp.mvm.parameters)[which(comp.mvm.parameters == 0)]
names.nrdp.zt.parameters <- rownames(comp.zt.parameters)[which(comp.zt.parameters == 0)]
names.nrdp.mms.parameters <- rownames(comp.mms.parameters)[which(comp.mms.parameters == 0)]

names.nrdp.parameters <- list(names.nrdp.mvm.parameters, names.nrdp.zt.parameters, names.nrdp.mms.parameters)
number.observed.non.RBPs.parameters <- c(length(names.nrdp.mvm.parameters), length(names.nrdp.zt.parameters), length(names.nrdp.mms.parameters))

# the proteins identified as RNA-dependent by kmeans-clustering:
comp.mvm.kmeans <- shift.kmeans[[1]]
comp.zt.kmeans <- shift.kmeans[[2]]
comp.mms.kmeans <- shift.kmeans[[3]]

names.rdp.mvm.kmeans <- rownames(comp.mvm.kmeans)[which(comp.mvm.kmeans == 1)]
names.rdp.zt.kmeans <- rownames(comp.zt.kmeans)[which(comp.zt.kmeans == 1)]
names.rdp.mms.kmeans <- rownames(comp.mms.kmeans)[which(comp.mms.kmeans == 1)]

names.rdp.kmeans <- list(names.rdp.mvm.kmeans, names.rdp.zt.kmeans, names.rdp.mms.kmeans)
number.observed.RBPs.kmeans <- c(length(names.rdp.mvm.kmeans), length(names.rdp.zt.kmeans), length(names.rdp.mms.kmeans))

# the proteins identified as non-RNA-dependent by kmeans-clustering:
names.nrdp.mvm.kmeans <- rownames(comp.mvm.kmeans)[which(comp.mvm.kmeans == 0)]
names.nrdp.zt.kmeans <- rownames(comp.zt.kmeans)[which(comp.zt.kmeans == 0)]
names.nrdp.mms.kmeans <- rownames(comp.mms.kmeans)[which(comp.mms.kmeans == 0)]

names.nrdp.kmeans <- list(names.nrdp.mvm.kmeans, names.nrdp.zt.kmeans, names.nrdp.mms.kmeans)
number.observed.non.RBPs.kmeans <- c(length(names.nrdp.mvm.kmeans), length(names.nrdp.zt.kmeans), length(names.nrdp.mms.kmeans))


# the proteins identified as RNA-dependent by the global shift parameter:
comp.glob <- shift_named
for(x in 1:3){
  for(y in 1:dim(comp.glob)[1]){
    if (shift_named[y,x] == "no shift"){
      comp.glob[y,x] <- 0
    }else{comp.glob[y,x] <- 1}
  }
}
names.rdp.mvm.glob <- rownames(as.data.frame(comp.glob[,1]))[which(as.data.frame(comp.glob[,1]) == 1)]
names.rdp.zt.glob <- rownames(as.data.frame(comp.glob[,2]))[which(as.data.frame(comp.glob[,2]) == 1)]
names.rdp.mms.glob <- rownames(as.data.frame(comp.glob[,3]))[which(as.data.frame(comp.glob[,3]) == 1)]

names.rdp.glob <- list(names.rdp.mvm.glob, names.rdp.zt.glob, names.rdp.mms.glob)


number.observed.RBPs.glob <- c(length(names.rdp.mvm.glob), length(names.rdp.zt.glob), length(names.rdp.mms.glob))
print(number.observed.RBPs.glob)

# the proteins identified as non-RNA-dependent by the global shift parameter:
names.nrdp.mvm.glob <- rownames(as.data.frame(comp.glob[,1]))[which(as.data.frame(comp.glob[,1]) == 0)]
names.nrdp.zt.glob <- rownames(as.data.frame(comp.glob[,2]))[which(as.data.frame(comp.glob[,2]) == 0)]
names.nrdp.mms.glob <- rownames(as.data.frame(comp.glob[,3]))[which(as.data.frame(comp.glob[,3]) == 0)]

names.nrdp.glob <- list(names.nrdp.mvm.glob, names.nrdp.zt.glob, names.nrdp.mms.glob)

number.observed.non.RBPs.glob <- c(length(names.nrdp.mvm.glob), length(names.nrdp.zt.glob), length(names.nrdp.mms.glob))

```

Using the parameters we have identified 464 RNA-associated Proteins with MVM, 468 with z-transformation and 396 with MMS.
Using the kmeans we have identified 160 RNA-associated Proteins with MVM, 155 with z-transformation and 159 with MMS.


### 11.1. True Positives

Check how many of our proteins really are RNA-dependent:

```{r}
#Number of correctly assigned (true positives) RBPs with parameters
true.positives.parameters <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.rdp.parameters[[z]]) {
    if (i %in% rdeep[,1]) {
      counter <- counter + 1
    }
  }
  true.positives.parameters[z] <- counter
}

#Number of correctly assigned (true positives) RBPs with kmeans
true.positives.kmeans <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.rdp.kmeans[[z]]) {
    if (i %in% rdeep[,1]) {
      counter <- counter + 1
    }
  }
  true.positives.kmeans[z] <- counter
}

#Number of correctly assigned (true positives) RBPs with global shift
true.positives.glob <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.rdp.glob[[z]]) {
    if (i %in% rdeep[,1]) {
      counter <- counter + 1
    }
  }
  true.positives.glob[z] <- counter
}
```


### 11.2. False positives

Check how many of our RNA-dependent proteins aren't really RNA-dependent:

```{r}
# Number of wrongly assigned (false positives) RBPs with parameters

false.positives.parameters <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.rdp.parameters[[z]]) {
    if (!(i %in% rdeep[,1]) & (!(i %in% rdeep.unknown[,1]))) {
      counter <- counter + 1
    }
  }
  false.positives.parameters[z] <- counter
}

# Number of wrongly assigned (false positives) RBPs with kmeans
false.positives.kmeans <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.rdp.kmeans[[z]]) {
    if (!(i %in% rdeep[,1]) & (!(i %in% rdeep.unknown[,1]))) {
      counter <- counter + 1
    }
  }
  false.positives.kmeans[z] <- counter
}

# Number of wrongly assigned (false positives) RBPs with global shift
false.positives.glob <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.rdp.glob[[z]]) {
    if (!(i %in% rdeep[,1]) & (!(i %in% rdeep.unknown[,1]))) {
      counter <- counter + 1
    }
  }
  false.positives.glob[z] <- counter
}
```


### 11.3. True negatives

Check how many of our non-RNA-dependent proteins really are non-RNA-dependent:

```{r}
# Number of correctly assigned non-RBPs (true negatives) with parameters

true.negatives.parameters <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.nrdp.parameters[[z]]) {
    if (!(i %in% rdeep[,1]) & (!(i %in% rdeep.unknown[,1]))) {
      counter <- counter + 1
    }
  }
  true.negatives.parameters[z] <- counter
}

# Number of correctly assigned non-RBPs (true negatives) with kmeans
true.negatives.kmeans <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.nrdp.kmeans[[z]]) {
    if (!(i %in% rdeep[,1]) & (!(i %in% rdeep.unknown[,1]))) {
      counter <- counter + 1
    }
  }
  true.negatives.kmeans[z] <- counter
}

# Number of correctly assigned non-RBPs (true negatives) with global shift
true.negatives.glob <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.nrdp.glob[[z]]) {
    if (!(i %in% rdeep[,1]) & (!(i %in% rdeep.unknown[,1]))) {
      counter <- counter + 1
    }
  }
  true.negatives.glob[z] <- counter
}
```


### 11.4. False negatives

Check how many of our non-RNA-dependent proteins aren't real non-RNA-dependent proteins:

```{r}
# Number of wrongly assigned non-RBPs (true negatives) with parameters
false.negatives.parameters <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.nrdp.parameters[[z]]) {
    if (i %in% rdeep[,1]) {
      counter <- counter + 1
    }
  }
  false.negatives.parameters[z] <- counter
}

#Number of correctly assigned (true positives) RBPs with parameters
false.negatives.kmeans <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.nrdp.kmeans[[z]]) {
    if (i %in% rdeep[,1]) {
      counter <- counter + 1
    }
  }
  false.negatives.kmeans[z] <- counter
}

#Number of correctly assigned (true positives) RBPs with global shift
false.negatives.glob <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(z in 1:3){
  counter <- 0
  for (i in names.nrdp.glob[[z]]) {
    if (i %in% rdeep[,1]) {
      counter <- counter + 1
    }
  }
  false.negatives.glob[z] <- counter
}
```


### 11.5. false-negative-rate (FNR)

FNR = FN/(FN + TP)

```{r}
fnr.parameters <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  fnr.parameters[x] <- false.negatives.parameters[x]/(false.negatives.parameters[x] + true.positives.parameters[x])
}

fnr.kmeans <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  fnr.kmeans[x] <- false.negatives.kmeans[x]/(false.negatives.kmeans[x] + true.positives.kmeans[x])
}

fnr.glob <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  fnr.glob[x] <- false.negatives.glob[x]/(false.negatives.glob[x] + true.positives.glob[x])
}
```



### 11.6. false-positive-rate (FPR)

FPR = FP/(FP + TN)

```{r}
fpr.parameters <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  fpr.parameters[x] <- false.positives.parameters[x]/(false.positives.parameters[x]+true.negatives.parameters[x])
}

fpr.kmeans <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  fpr.kmeans[x] <- false.positives.kmeans[x]/(false.positives.kmeans[x]+true.negatives.kmeans[x])
}

fpr.glob <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  fpr.glob[x] <- false.positives.glob[x]/(false.positives.glob[x]+true.negatives.glob[x])
}
```



### 11.7. Precision

precision = TP/(TP + FP)

```{r}
precision.parameters <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  precision.parameters[x] <- true.positives.parameters[x]/(true.positives.parameters[x] + false.positives.parameters[x])
}

precision.kmeans <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  precision.kmeans[x] <- true.positives.kmeans[x]/(true.positives.kmeans[x] + false.positives.kmeans[x])
}

precision.glob <- data.frame(mvm = c(0), zt = c(0), mms = c(0))
for(x in 1:3){
  precision.glob[x] <- true.positives.glob[x]/(true.positives.glob[x] + false.positives.glob[x])
}
```


### 11.8. non-comparable Proteins

Here we identify those proteins that aren't in the Rdeep 2.0 database, but were analyzed by us. 

```{r}
non.comparable.mvm.parameters <- rownames(comp.mvm.parameters)[which(rownames(comp.mvm.parameters) %in% rdeep.unknown[,1])]
non.comparable.zt.parameters <- rownames(comp.zt.parameters)[which(rownames(comp.zt.parameters) %in% rdeep.unknown[,1])]
non.comparable.mms.parameters <- rownames(comp.mms.parameters)[which(rownames(comp.mms.parameters) %in% rdeep.unknown[,1])]

non.comparable.mvm.kmeans <- rownames(comp.mvm.kmeans)[which(rownames(comp.mvm.kmeans) %in% rdeep.unknown[,1])]
non.comparable.zt.kmeans <- rownames(comp.zt.kmeans)[which(rownames(comp.zt.kmeans) %in% rdeep.unknown[,1])]
non.comparable.mms.kmeans <- rownames(comp.mms.kmeans)[which(rownames(comp.mms.kmeans) %in% rdeep.unknown[,1])]

#shifting?
shifting.non.comparable.mvm.parameters <- comp.mvm.parameters[which(rownames(comp.mvm.parameters) %in% rdeep.unknown[,1]),]
shifting.non.comparable.zt.parameters <- comp.zt.parameters[which(rownames(comp.zt.parameters) %in% rdeep.unknown[,1]),]
shifting.non.comparable.mms.parameters <- comp.mms.parameters[which(rownames(comp.mms.parameters) %in% rdeep.unknown[,1]),]

shifting.non.comparable.mvm.kmeans <- comp.mvm.kmeans[which(rownames(comp.mvm.kmeans) %in% rdeep.unknown[,1]),]
shifting.non.comparable.zt.kmeans <- comp.zt.kmeans[which(rownames(comp.zt.kmeans) %in% rdeep.unknown[,1]),]
shifting.non.comparable.mms.kmeans <- comp.mms.kmeans[which(rownames(comp.mms.kmeans) %in% rdeep.unknown[,1]),]


non.comparable.parameters <- data.frame(mvm = c(non.comparable.mvm.parameters, length(non.comparable.mvm.parameters)),
                                        "RDeep? mvm" = c(shifting.non.comparable.mvm.parameters,
                                                            sum(shifting.non.comparable.mvm.parameters)),
                                        zt = c(non.comparable.zt.parameters, length(non.comparable.zt.parameters)),
                                        "RDeep? zt" = c(shifting.non.comparable.zt.parameters,
                                                           sum(shifting.non.comparable.zt.parameters)),
                                        mms = c(non.comparable.mms.parameters,length(non.comparable.mms.parameters)),
                                        "RDeep? mms" = c(shifting.non.comparable.mms.parameters,
                                                            sum(shifting.non.comparable.mms.parameters)))
colnames(non.comparable.parameters) = c("mvm", "RDeep?", "zt", "RDeep?", "mms", "RDeep?")

non.comparable.kmeans <- data.frame(mvm = c(non.comparable.mvm.kmeans, length(non.comparable.mvm.kmeans)),
                                        "RDeep? mvm" = c(shifting.non.comparable.mvm.kmeans,
                                                            sum(shifting.non.comparable.mvm.kmeans)),
                                        zt = c(non.comparable.zt.kmeans, length(non.comparable.zt.kmeans)),
                                        "RDeep? zt" = c(shifting.non.comparable.zt.kmeans,
                                                           sum(shifting.non.comparable.zt.kmeans)),
                                        mms = c(non.comparable.mms.kmeans,length(non.comparable.mms.kmeans)),
                                        "RDeep? mms" = c(shifting.non.comparable.mms.kmeans,
                                                            sum(shifting.non.comparable.mms.kmeans)))

colnames(non.comparable.kmeans) = c("mvm", "RDeep?", "zt", "RDeep?", "mms", "RDeep?")

number.non.comparable.parameters <- data.frame(mvm = length(non.comparable.mvm.parameters), 
                                        zt = length(non.comparable.zt.parameters), 
                                        mms = length(non.comparable.mms.parameters))
number.non.comparable.kmeans <- data.frame(mvm = length(non.comparable.mvm.kmeans), 
                                    zt = length(non.comparable.zt.kmeans), 
                                    mms = length(non.comparable.mms.kmeans))

#View(non.comparable.parameters)
#View(non.comparable.kmeans)

#a data frame that sums it all up
non.comparable.all <- cbind(non.comparable.parameters[,c(1, 2, 4, 6)], non.comparable.kmeans[,c(2, 4, 6)])
colnames(non.comparable.all) <- c("Name", "RDeep according to parameters mvm", "RDeep according to parameters zt", "RDeep according to parameters mms", "RDeep according to kmeans mvm", "RDeep according to kmeans zt", "RDeep according to kmeans mms")
rownames(non.comparable.all) <- c(1:22,"total")

library("kableExtra")
non.comparable.all0 <- kable(non.comparable.all, align = "c")
table.non.comparable.all <- kable_styling(non.comparable.all0, "striped", full_width = FALSE)

print(table.non.comparable.all, row.names = FALSE)
```

### 11.9. Summary

These data frames show all results of the comparison. 

```{r}
#for the results of our parameters
summary.numbers.parameters <- rbind(true.positives.parameters, false.positives.parameters, true.negatives.parameters, false.negatives.parameters)
rownames(summary.numbers.parameters) = c("True Positives","False Positives", "True Negatives", "False Negatives")

summary.rates.parameters <- rbind(fnr.parameters , fpr.parameters, precision.parameters)
rownames(summary.rates.parameters) = c("FNR", "FPR", "Precision")

#View(summary.numbers.parameters)
#View(summary.rates.parameters)

#for the results of kmeans
summary.numbers.kmeans <- rbind(true.positives.kmeans, false.positives.kmeans, true.negatives.kmeans, false.negatives.kmeans)
rownames(summary.numbers.kmeans) = c("True Positives","False Positives", "True Negatives", "False Negatives")

summary.rates.kmeans <- rbind(fnr.kmeans , fpr.kmeans, precision.kmeans)
rownames(summary.rates.kmeans) = c("FNR", "FPR", "Precision")

#View(summary.numbers.kmeans)
#View(summary.rates.kmeans)

#for the results of global shift
summary.numbers.glob <- rbind(true.positives.glob, false.positives.glob, true.negatives.glob, false.negatives.glob)
rownames(summary.numbers.glob) = c("True Positives","False Positives", "True Negatives", "False Negatives")

summary.rates.glob <- rbind(fnr.glob , fpr.glob, precision.glob)
rownames(summary.rates.glob) = c("FNR", "FPR", "Precision")

#View(summary.numbers.glob)
#View(summary.rates.glob)


#a data frame that sums it all up
summary.numbers.all <- cbind(summary.numbers.glob, summary.numbers.parameters, summary.numbers.kmeans)
colnames(summary.numbers.all) <- c("global shift mvm", "global shift zt", "global shift mms", "parameters mvm", "parameters zt", "parameters mms", "kmeans mvm", "kmeans zt", "kmeans mms")

summary.rates.all <- cbind(summary.rates.glob, summary.rates.parameters, summary.rates.kmeans)
colnames(summary.rates.all) <- c("global shift mvm", "global shift zt", "global shift mms", "parameters mvm", "parameters zt", "parameters mms", "kmeans mvm", "kmeans zt", "kmeans mms")

View(summary.numbers.all)
View(summary.rates.all)

```


